<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        <meta name="author" content="https://github.com/wujun4code">
        
        <link rel="shortcut icon" href="../../img/favicon.ico">

	<title>LeanCloud 数据存储 TypeScript SDK 使用指南 - LeanCloud Edge</title>

        <link href="../../css/bootstrap-custom.min.css" rel="stylesheet">
        <link href="../../css/font-awesome-4.0.3.css" rel="stylesheet">
        <link rel="stylesheet" href="../../css/highlight.css">
        <link href="../../css/base.css" rel="stylesheet">

        <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
        <!--[if lt IE 9]>
            <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
            <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
        <![endif]-->

        
        <script>
            (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
            m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
            })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

            ga('create', 'UA-80849258-1', 'gitpage');
            ga('send', 'pageview');
        </script>
        
    </head>

    <body>

        <div class="navbar navbar-default navbar-fixed-top" role="navigation">
    <div class="container">

        <!-- Collapsed navigation -->
        <div class="navbar-header">
            <!-- Expander button -->
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>

            <!-- Main title -->
            <a class="navbar-brand" href="../..">LeanCloud Edge</a>
        </div>

        <!-- Expanded navigation -->
        <div class="navbar-collapse collapse">
            <!-- Main navigation -->
            <ul class="nav navbar-nav">
            
            
                <li >
                    <a href="../..">首页</a>
                </li>
            
            
            
                <li class="dropdown active">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">TypeScript <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        
<li >
    <a href="../get-started/">SDK 安装与初始化</a>
</li>

                    
                        
<li class="active">
    <a href="./">LeanCloud 数据存储 TypeScript SDK 使用指南</a>
</li>

                    
                    </ul>
                </li>
            
            
            
                <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">Ionic2 <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        
<li >
    <a href="../../ionic2/leancloud_push_notification/">使用 LeanCloud 推送</a>
</li>

                    
                    </ul>
                </li>
            
            
            
                <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">.NET <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        
<li >
    <a href="../../dotnet/asp_net_core/">ASP.NET Core</a>
</li>

                    
                    </ul>
                </li>
            
            
            
                <li >
                    <a href="../../about/">关于</a>
                </li>
            
            
            </ul>

            <!-- Search, Navigation and Repo links -->
            <ul class="nav navbar-nav navbar-right">
                <li>
                    <a href="#" data-toggle="modal" data-target="#mkdocs_search_modal">
                        <i class="fa fa-search"></i> Search
                    </a>
                </li>
                <li >
                    <a rel="next" href="../get-started/">
                        <i class="fa fa-arrow-left"></i> Previous
                    </a>
                </li>
                <li >
                    <a rel="prev" href="../../ionic2/leancloud_push_notification/">
                        Next <i class="fa fa-arrow-right"></i>
                    </a>
                </li>
                
                <li>
                    <a href="https://github.com/wujun4code/LeanEdge">
                        
                            <i class="fa fa-github"></i>
                        
                        GitHub
                    </a>
                </li>
                
            </ul>
        </div>
    </div>
</div>

        <div class="container">
            <div class="col-md-3"><div class="bs-sidebar hidden-print affix well" role="complementary">
    <ul class="nav bs-sidenav">
    
        <li class="main active"><a href="#leancloud-typescript-sdk">LeanCloud 数据存储 TypeScript SDK 使用指南</a></li>
        
            <li><a href="#_1">简介</a></li>
        
            <li><a href="#sdk">SDK 安装</a></li>
        
            <li><a href="#web">Web 安全</a></li>
        
            <li><a href="#_2">对象</a></li>
        
            <li><a href="#_20">文件</a></li>
        
            <li><a href="#_29">查询</a></li>
        
            <li><a href="#promise">Promise</a></li>
        
            <li><a href="#_56">用户</a></li>
        
            <li><a href="#_77">角色</a></li>
        
            <li><a href="#_78">应用内搜索</a></li>
        
            <li><a href="#_79">应用内社交</a></li>
        
            <li><a href="#push">Push 通知</a></li>
        
            <li><a href="#webview">WebView 中使用</a></li>
        
    
    </ul>
</div></div>
            <div class="col-md-9" role="main">

<h1 id="leancloud-typescript-sdk">LeanCloud 数据存储 TypeScript SDK 使用指南</h1>
<h2 id="_1">简介</h2>
<p>数据存储（LeanStorage）是 LeanCloud 提供的核心功能之一，它的使用方法与传统的关系型数据库有诸多不同。下面我们将其与传统数据库的使用方法进行对比，让大家有一个初步了解。</p>
<p>下面这条 SQL 语句在绝大数的关系型数据库都可以执行，其结果是在 Todo 表里增加一条新数据：</p>
<pre><code class="sql">  INSERT INTO Todo (title, content) VALUES ('工程师周会', '每周工程师会议，周一下午2点')
</code></pre>

<p>使用传统的关系型数据库作为应用的数据源几乎无法避免以下步骤：</p>
<ul>
<li>插入数据之前一定要先创建一个表结构，并且随着之后需求的变化，开发者需要不停地修改数据库的表结构，维护表数据。</li>
<li>每次插入数据的时候，客户端都需要连接数据库来执行数据的增删改查（CRUD）操作。</li>
</ul>
<p>使用 LeanStorage，实现代码如下：</p>
<pre><code class="ts">  let todo = new AV.Object('Todo');
  todo.set('title', '工程师周会');
  todo.set('content', '每周工程师会议，周一下午2点');
  todo.save&lt;AV.Object&gt;().then(
      (data) =&gt; {
        // data 是根据 todo.save&lt;AV.Object&gt; 传入的泛型参数决定
        let savedTodo : AV.Object = data;
      },
      (error) =&gt; {
        if(error) throw error;
      }
  );
</code></pre>

<p>使用 LeanStorage 的特点在于：</p>
<ul>
<li>不需要单独维护表结构。例如，为上面的 Todo 表新增一个 <code>location</code> 字段，用来表示日程安排的地点，那么刚才的代码只需做如下变动：</li>
</ul>
<pre><code class="ts">  let todo = new AV.Object('Todo');
  todo.set('title', '工程师周会');
  todo.set('content', '每周工程师会议，周一下午2点');
  todo.set('location', '会议室');//只要添加这一行代码，服务端就会自动添加这个字段
  todo.save&lt;AV.Object&gt;().then(
      (data) =&gt; {
        // data 是根据 todo.save&lt;AV.Object&gt; 传入的泛型参数决定
        let savedTodo : AV.Object = data;
        console.log(savedTodo.get('location'));
      },
      (error) =&gt; {
        if(error) throw error;
      }
  );
</code></pre>

<ul>
<li>数据可以随用随加，这是一种无模式化（Schema Free）的存储方式。</li>
<li>所有对数据的操作请求都通过 HTTPS 访问标准的 REST API 来实现。</li>
<li>我们为各个平台或者语言开发的 SDK 在底层都是调用统一的 REST API，并提供完整的接口对数据进行增删改查。</li>
</ul>
<p>LeanStorage 在结构化数据存储方面，与 DB 的区别在于：</p>
<ol>
<li>Schema Free／Not free 的差异；</li>
<li>数据接口上，LeanStorage 是面向对象的（数据操作接口都是基于 Object 的），开放的（所有移动端都可以直接访问），DB 是面向结构的，封闭的（一般在 Server 内部访问）；</li>
<li>数据之间关联的方式，DB 是主键外键模型，LeanStorage 则有自己的关系模型（Pointer、Relation 等）；</li>
</ol>
<p>LeanStorage 支持两种存储类型：</p>
<ul>
<li>对象</li>
<li>文件</li>
</ul>
<p>我们将按照顺序逐一介绍各类的使用方法。</p>
<h2 id="sdk">SDK 安装</h2>
<p>请阅读 <a href="../sdk_setup-js.html">JavaScript 安装指南</a>。</p>
<h2 id="web">Web 安全</h2>
<p>如果在前端使用 JavaScript SDK，当你打算正式发布的时候，请务必配置 <strong>Web 安全域名</strong>。配置方式为：进入 <a href="../../app.html?appid={{appid}}#/security">控制台 / 设置 / 安全中心 / <strong>Web 安全域名</strong></a>。这样就可以防止其他人，通过外网其他地址盗用你的服务器资源。</p>
<p>具体安全相关内容可以仔细阅读文档 <a href="../data_security.html">数据和安全</a> 。</p>
<h2 id="_2">对象</h2>
<p><code>AV.Object</code> 是 LeanStorage 对复杂对象的封装，每个 <code>AVObject</code> 包含若干属性值对，也称键值对（key-value）。属性的值是与 JSON 格式兼容的数据。通过 REST API 保存对象需要将对象的数据通过 JSON 来编码。这个数据是无模式化的（Schema Free），这意味着你不需要提前标注每个对象上有哪些 key，你只需要随意设置 key-value 对就可以，云端会保存它。</p>
<h3 id="_3">构建对象</h3>
<p>构建一个 <code>AV.Object</code> 可以使用如下方式：</p>
<pre><code class="ts">  // AV.Object.extend('className') 所需的参数 className 则表示对应的表名
  var Todo = AV.Object.extend('Todo');

  // 在 TypeScript 当中我们推荐如下创建对象的方式
  let todo = new AV.Object('Todo');

//https://github.com/leancloud/TypeScript-Sample-Code/blob/master/sample/Object/AVObject%23new.ts
</code></pre>

<p><strong>注意</strong>：<code>AV.Object.extend</code> 产生的对象需要作为全局变量保存，因为每调用
一次，就会产生一个新的类的实例，并且和之前创建的实例形成一个链表。
如果你的应用时不时出现 <code>Maximum call stack size exceeded</code> 错误，请
确认是否误用了该方法。</p>
<p>每个 id 必须有一个 Class 类名称，这样云端才知道它的数据归属于哪张数据表。</p>
<h3 id="_4">保存对象</h3>
<p>现在我们保存一个 <code>TodoFolder</code>，它可以包含多个 Todo，类似于给行程按文件夹的方式分组。我们并不需要提前去后台创建这个名为 <strong>TodoFolder</strong> 的 Class 类，而仅需要执行如下代码，云端就会自动创建这个类：</p>
<pre><code class="ts">  let todoFolder:AV.Object = new AV.Object('TodoFolder');// 新建对象
  todoFolder.set('name','工作');// 设置名称
  todoFolder.set('priority',1);// 设置优先级
  todoFolder.save&lt;AV.Object&gt;().then(
    (data) =&gt; {
      let savedTodoFolder : AV.Object = data;
  },(error)=&gt;{
    if(error) throw error;
  });
</code></pre>

<p>创建完成后，打开 <a href="../../data.html?appid={{appid}}#/">控制台 &gt; 存储</a>，点开 <code>TodoFolder</code> 类，就可以看到刚才添加的数据。除了 name、priority（优先级）之外，其他字段都是数据表的内置属性。</p>
<table>
<thead>
<tr>
<th>内置属性</th>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>id</code></td>
<td>String</td>
<td>该对象唯一的 Id 标识</td>
</tr>
<tr>
<td><code>ACL</code></td>
<td>ACL</td>
<td>该对象的权限控制，实际上是一个 JSON 对象，控制台做了展现优化。</td>
</tr>
<tr>
<td><code>createdAt</code></td>
<td>Date</td>
<td>该对象被创建的 UTC 时间，控制台做了针对当地时间的展现优化。</td>
</tr>
<tr>
<td><code>updatedAt</code></td>
<td>Date</td>
<td>该对象最后一次被修改的时间</td>
</tr>
</tbody>
</table>
<dl>
  <dt>属性名</dt>
  <dd>也叫键或 key，必须是由字母、数字或下划线组成的字符串；自定义的属性名，不能以 `__`（双下划线）开头。</dd>
  <dt>属性值</dt>
  <dd>可以是字符串、数字、布尔值、数组或字典。</dd>
</dl>

<div class="callout callout-danger"><p>以下为系统保留字段，不能作为属性名来使用。</p>
<samp style="color:#666;">acl             error            pendingKeys
ACL             fetchWhenSave    running
className       id               updatedAt
code            isDataReady      uuid
createdAt       keyValues
description     objectId
</samp>
</div>

<p>为提高代码的可读性和可维护性，建议使用驼峰式命名法（CamelCase）为类和属性来取名。类，采用大驼峰法，如 <code>CustomData</code>。属性，采用小驼峰法，如 <code>imageUrl</code>。</p>
<h4 id="cql">使用 CQL 语法保存对象</h4>
<p>LeanStorage 提供了类似 SQL 语法中的 Insert 方式保存一个对象，例如保存一个 TodoFolder 对象可以使用下面的代码：</p>
<pre><code class="ts">  // 执行 CQL 语句实现新增一个 TodoFolder 对象
  AV.Query.doCloudQuery&lt;any&gt;('insert into TodoFolder(name, priority) values(&quot;工作&quot;, 1)').then(
    (data) =&gt; {
      // 传入泛型参数提高代码阅读性以及后续的智能提示
      let savedTodo : AV.Object = data.results[0];
    },
    (error) =&gt; {
    if(error) throw error;
    }
  );
</code></pre>

<h4 id="_5">保存选项</h4>
<p><code>AV.Object</code> 对象在保存时可以设置选项来快捷完成关联操作，可用的选项属性有：</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code class="text-nowrap">fetchWhenSave</code></td>
<td>BOOL</td>
<td>对象成功保存后，自动返回该对象在云端的最新数据。用途请参考 <a href="#更新计数器">更新计数器</a>。</td>
</tr>
<tr>
<td><code>query</code></td>
<td><code>AV.Query</code></td>
<td>当 query 中的条件满足后对象才能成功保存，否则放弃保存，并返回错误码 305。<br/><br/>开发者原本可以通过 <code>AV.Query</code> 和 <code>AV.Object</code> 分两步来实现这样的逻辑，但如此一来无法保证操作的原子性从而导致并发问题。该选项可以用来判断多用户更新同一对象数据时可能引发的冲突。</td>
</tr>
</tbody>
</table>
<p><a id="saveoption_query_example" name="saveoption_query_example"></a>【示例】一篇 wiki 文章允许任何人来修改，它的数据表字段有：<strong>content</strong>（wiki 内容）、<strong>version</strong>（版本号）。每当 wiki 内容被更新后，其 version 也需要更新（+1）。用户 A 要修改这篇 wiki，从数据表中取出时其 version 值为 3，当用户 A 完成编辑要保存新内容时，如果数据表中的 version 仍为 3，表明这段时间没有其他用户更新过这篇 wiki，可以放心保存；如果不是 3，开发者可以拒绝掉用户 A 的修改，或执行其他自定义的业务逻辑。</p>
<pre><code class="ts">  new AV.Query('Wiki').first&lt;AV.Object&gt;().then((data) =&gt; {
    let wiki:AV.Object = data;
    let currentVersion = wiki.get('version');
    wiki.set('version',currentVersion + 1);
    wiki.save&lt;AV.Object&gt;(null,{
      query:new AV.Query('Wiki').equalTo('version', currentVersion)
    }).then((data) =&gt;{
    // data 是一个 AV.Object 并且是版本更新之后的 Wiki 对象
    },error=&gt;{
      if(error) throw error;
    });
  },error=&gt;{
    if(error) throw error;
  })
</code></pre>

<h3 id="_6">数据类型</h3>
<p><code>AV.Object</code> 支持以下数据类型：</p>
<pre><code class="ts">  let testNumber : number = 13;
  let testString : string = 'here is a test string';
  let testDate : Date = new Date('2016-06-04');
  let testNumberArray : Array&lt;number&gt; = [1, 2, 3];
  let testStringArray : Array&lt;string&gt; = ['here','is','a','string','array'];
  let testObjectType : Object = {name:'LeanCloud',url:'https://leancloud.cn'};

  let testAVObject = new AV.Object('TestClass');
  testAVObject.set('testNumber', testNumber);
  testAVObject.set('testString', testString);
  testAVObject.set('testDate', testDate);
  testAVObject.set('testNumberArray', testNumberArray);
  testAVObject.set('testStringArray', testStringArray);
  testAVObject.set('testObject', testObjectType);

  testAVObject.save&lt;AV.Object&gt;().then(
    (data) =&gt; {
  },(error) =&gt;{
    if(error) throw error;
  });
</code></pre>

<p>我们<strong>不推荐</strong>在 <code>AV.Object</code> 中储存大块的二进制数据，比如图片或整个文件。<strong>每个 <code>AV.Object</code> 的大小都不应超过 128 KB</strong>。如果需要储存更多的数据，建议使用 <a href="#文件"><code>AV.File</code></a>。</p>
<p>若想了解更多有关 LeanStorage 如何解析处理数据的信息，请查看专题文档《<a href="../data_security.html">数据与安全</a>》。</p>
<h3 id="_7">获取对象</h3>
<p>每个被成功保存在云端的对象会有一个唯一的 Id 标识 <code>id</code>，因此获取对象的最基本的方法就是根据 <code>id</code> 来查询：</p>
<pre><code class="ts">  var query = new AV.Query('Todo');
  query.get&lt;AV.Object&gt;('57328ca079bc44005c2472d0').then((data)=&gt;{
    // 成功获得实例
    // data 就是 id 为 57328ca079bc44005c2472d0 的 Todo 对象实例
  },(error)=&gt;{
    if(error) throw error;
  });
</code></pre>

<p>如果不想使用查询，还可以通过从本地构建一个 <code>id</code>，然后调用接口从云端把这个 <code>id</code> 的数据拉取到本地，示例代码如下：</p>
<pre><code class="ts">  // 第一个参数是 className，第二个参数是 objectId
  let todo : AV.Object = AV.Object.createWithoutData('Todo','5745557f71cfe40068c6abe0');
  let title = todo.get('title');// 读取 title
  let content = todo.get('content');// 读取 content
</code></pre>

<h4 id="objectid">获取 objectId</h4>
<p>每一次对象存储成功之后，云端都会返回 <code>id</code>，它是一个全局唯一的属性。</p>
<pre><code class="ts">  let todo : AV.Object = new AV.Object('Todo');
  todo.set('title', '工程师周会');
  todo.set('content', '每周工程师会议，周一下午2点');
  todo.save&lt;AV.Object&gt;().then((data) =&gt; {
    // 成功保存之后，执行其他逻辑
    let objectId = data.id;// 获取 objectId
  },  (error)=&gt; {
    // 失败之后执行其他逻辑
    // error 是 AV.Error 的实例，包含有错误码和描述信息.
  });
</code></pre>

<h4 id="_8">访问对象的属性</h4>
<p>访问 Todo 的属性的方式为：</p>
<pre><code class="ts">  let query : AV.Query = new AV.Query('Todo');
  query.get&lt;AV.Object&gt;('57328ca079bc44005c2472d0').then((todo)=&gt;{
    let priority : number = todo.get('priority');
    let location : string = todo.get('location');// 可以指定读取的类型
    let title = todo.get('title');// 也可以不指定读取的类型

    // 获取三个特殊属性
    let objectId : string = todo.id;
    var updatedAt : Date = todo.updatedAt;
    var createdAt : Date = todo.createdAt;
    console.log(createdAt);//Wed May 11 2016 09:36:32 GMT+0800 (CST)
  },(error)=&gt;{
    if(error) throw error;
  });
</code></pre>

<p>请注意以上代码中访问三个特殊属性 <code>id</code>、<code>createdAt</code>、<code>updatedAt</code> 的方式。</p>
<p>如果访问了并不存在的属性，SDK 并不会抛出异常，而是会返回空值。</p>
<h4 id="_9">默认属性</h4>
<p>默认属性是所有对象都会拥有的属性，它包括 <code>id</code>、<code>createdAt</code>、<code>updatedAt</code>。</p>
<dl>
  <dt>`createdAt`</dt>
  <dd>对象第一次保存到云端的时间戳。该时间一旦被云端创建，在之后的操作中就不会被修改。它采用国际标准时区 UTC，开发者可能需要根据客户端当前的时区做转化。</dd>
  <dt>`updatedAt`</dt>
  <dd>对象最后一次被修改（或最近一次被更新）的时间。</dd>
</dl>

<h4 id="_10">同步对象</h4>
<p>多终端共享一个数据时，为了确保当前客户端拿到的对象数据是最新的，可以调用刷新接口来确保本地数据与云端的同步：</p>
<pre><code class="ts">  let todo : AV.Object = new AV.Object('Todo');
  todo.id = '57328ca079bc44005c2472d0';
  todo.fetch&lt;AV.Object&gt;().then((todo)=&gt;{
    // todo 是从服务器加载到本地的 AV.Object
    let priority : number = todo.get('priority');// 读取 todo 的属性
  },(error)=&gt;{
    if(error) throw error;
  });
</code></pre>

<p>在更新对象操作后，对象本地的 updatedAt 字段（最后更新时间）会被刷新，直到下一次 save 或 fetch 操作，updatedAt 的最新值才会被同步到云端，这样做是为了减少网络流量传输。</p>
<p>如果需要在保存或更新之后让本地数据自动与云端保持一致，可以使用 <a href="#保存选项">保存选项 <code>fetchWhenSave</code></a>：</p>
<pre><code class="ts">  let todo : AV.Object = new AV.Object('Todo');
  todo.fetchWhenSave(true);
  todo.save&lt;AV.Object&gt;().then((data)=&gt;{
    // 保存成功
  },(error)=&gt;{
    if(error) throw error;
  });
</code></pre>

<h4 id="_11">同步指定属性</h4>
<p>目前 Todo 这个类已有四个自定义属性：<code>priority</code>、<code>content</code>、<code>location</code> 和 <code>title</code>。为了节省流量，现在只想刷新 <code>priority</code> 和 <code>location</code> 可以使用如下方式：</p>
<pre><code class="ts">  // 使用已知 objectId 构建一个 AV.Object
  let todo:AV.Object = AV.Object.createWithoutData('Todo', '57328ca079bc44005c2472d0');
  //  传入 include 参数，指定获取的属性
  todo.fetch&lt;AV.Object&gt;(
    {include:'priority,location'
  },{}).then(
    (todo) =&gt;{
    // 获取到本地
  }, (error) =&gt;{
    if(error) throw error;
  });
</code></pre>

<p><strong>刷新操作会强行使用云端的属性值覆盖本地的属性</strong>。因此如果本地有属性修改，请慎用这类接口。</p>
<h3 id="_12">更新对象</h3>
<p>LeanStorage 上的更新对象都是针对单个对象，在确保对象的 objectId 不为空才可以更新对象。云端根据<u>有没有 objectId</u> 来决定一个对象是新增还是更新。</p>
<pre><code class="ts">  // 已知 objectId，创建 AV.Object
  // 第一个参数是 className，第二个参数是该对象的 objectId
  let todo:AV.Object = AV.Object.createWithoutData('Todo', '558e20cbe4b060308e3eb36c');
  // 更改属性
  todo.set('location', '二楼大会议室');
  todo.save&lt;AV.Object&gt;().then((todo)=&gt;{
    // 保存成功，可以打开控制台核对修改结果
    done();
  },(error)=&gt;{
    if(error) throw error;
  });
</code></pre>

<p>需要特别声明是，更新操作是覆盖式的，云端会根据最后一次提交到服务器的有效请求更新数据。更新是字段级别的操作，未更新的字段不会产生变动，这一点请不用担心。</p>
<p>另外，假如已知了 <code>id</code>，可以通过如下接口从本地构建一个 <code>AV.Object</code>，然后更新这个对象：</p>
<pre><code class="ts">  // 第一个参数是 className，第二个参数是 objectId
  let todo : AV.Object = AV.Object.createWithoutData('Todo','5745557f71cfe40068c6abe0');
  // 修改属性
  todo.set('content','每周工程师会议，本周改为周三下午3点半。');
  // 保存到云端
  todo.save();
</code></pre>

<h4 id="cql_1">使用 CQL 语法更新对象</h4>
<p>LeanStorage 提供了类似 SQL 语法中的 Update 方式更新一个对象，例如更新一个 TodoFolder 对象可以使用下面的代码：</p>
<pre><code class="ts">  // 执行 CQL 语句实现更新一个 TodoFolder 对象
  AV.Query.doCloudQuery&lt;any&gt;('update TodoFolder set name=&quot;家庭&quot; where objectId=&quot;558e20cbe4b060308e3eb36c&quot;').then(
    (data) =&gt; {
      let savedTodo : AV.Object = data.results[0];
    },
    (error) =&gt; {
      if(error) throw error;
    }
  );
</code></pre>

<h4 id="_13">更新计数器</h4>
<p>这是原子操作（Atomic Operation）的一种。
为了存储一个整型的数据，LeanStorage 提供对任何数字字段进行原子增加（或者减少）的功能。比如一条微博，我们需要记录有多少人喜欢或者转发了它，但可能很多次喜欢都是同时发生的。如果在每个客户端都直接把它们读到的计数值增加之后再写回去，那么极容易引发冲突和覆盖，导致最终结果不准。此时就需要使用这类原子操作来实现计数器。</p>
<p>假如，现在增加一个记录查看 Todo 次数的功能，一些与他人共享的 Todo 如果不用原子操作的接口，很有可能会造成统计数据不准确，可以使用如下代码实现这个需求：</p>
<pre><code class="ts">  let todo:AV.Object = AV.Object.createWithoutData('Todo', '57328ca079bc44005c2472d0');
  todo.set('views',0);
  todo.save&lt;AV.Object&gt;().then((todo)=&gt;{
    todo.increment(&quot;views&quot;,1);
    todo.fetchWhenSave(true);
    // 也可以指定增加一个特定的值
    // 例如一次性加 5
    todo.increment(&quot;views&quot;,5);
    todo.save&lt;AV.Object&gt;().then((data)=&gt;{
      // 因为使用了 fetchWhenSave 选项，save 调用之后，如果成功的话，对象的计数器字段是当前系统最新值。
    },(error)=&gt;{
      if(error) throw error;
    });
  },(error)=&gt;{
    if(error) throw error;
  });
</code></pre>

<h4 id="_14">更新数组</h4>
<p>这也是原子操作的一种。使用以下方法可以方便地维护数组类型的数据：</p>
<ul>
<li><code>AV.Object.add('arrayKey',arrayValue)</code><br>
  将指定对象附加到数组末尾。</li>
<li><code>AV.Object.addUnique('arrayKey',arrayValue);</code><br>
  如果不确定某个对象是否已包含在数组字段中，可以使用此操作来添加。对象的插入位置是随机的。</li>
<li><code>AV.Object.remove('arrayKey',arrayValue);</code><br>
  从数组字段中删除指定对象的所有实例。</li>
</ul>
<p>例如，Todo 对象有一个提醒日期 reminders，它是一个数组，代表这个日程会在哪些时间点提醒用户。比如有些拖延症患者会把闹钟设为早上的 7:10、7:20、7:30：</p>
<pre><code class="ts">  let reminder1: Date = new Date('2015-11-11 07:10:00');
  let reminder2: Date = new Date('2015-11-11 07:20:00');
  let reminder3: Date = new Date('2015-11-11 07:30:00');

  let reminders : Array&lt;Date&gt; = [reminder1,reminder2,reminder3];

  let todo : AV.Object = new AV.Object('Todo');
  todo.addUnique('reminders',reminders);
  todo.save&lt;AV.Object&gt;().then((todo)=&gt;{
  },(error)=&gt;{
  })
</code></pre>

<h3 id="_15">删除对象</h3>
<p>假如某一个 Todo 完成了，用户想要删除这个 Todo 对象，可以如下操作：</p>
<pre><code class="ts">  let todo:AV.Object = AV.Object.createWithoutData('Todo', '57328ca079bc44005c2472d0');
  todo.destroy().then(
    (success)=&gt;{
    // 删除成功
  },(error)=&gt;{
    // 删除失败
  });
</code></pre>

<div class="callout callout-danger">删除对象是一个较为敏感的操作。在控制台创建对象的时候，默认开启了权限保护，关于这部分的内容请阅读《[JavaScript 权限管理使用指南](acl_guide-js.html)》。</div>

<h4 id="cql_2">使用 CQL 语法删除对象</h4>
<p>LeanStorage 提供了类似 SQL 语法中的 Delete 方式删除一个对象，例如删除一个 Todo 对象可以使用下面的代码：</p>
<pre><code class="ts">  // 执行 CQL 语句实现删除一个 Todo 对象
  AV.Query.doCloudQuery&lt;AV.Object&gt;('delete from Todo where objectId=&quot;558e20cbe4b060308e3eb36c&quot;').then(
    (data) =&gt; {
    },
    (error) =&gt; {
    }
  );
</code></pre>

<h3 id="_16">批量操作</h3>
<p>为了减少网络交互的次数太多带来的时间浪费，你可以在一个请求中对多个对象进行创建、更新、删除、获取。接口都在 <code>AV.Object</code> 这个类下面：</p>
<pre><code class="ts">  let avObjectArray:Array&lt;AV.Object&gt; = [/*...*/];// 构建一个 AV.object 数组

  // 批量创建、更新
  AV.Object.saveAll&lt;AV.Object []&gt;(avObjectArray).then((avobjs)=&gt;{
  },(error)=&gt;{
  });

  // 批量删除
  AV.Object.destroyAll&lt;AV.Object []&gt;(avObjectArray).then((avobjs)=&gt;{
  },(error)=&gt;{
  });

  // 批量获取
  AV.Object.fetchAll&lt;AV.Object []&gt;(avObjectArray).then((avobjs)=&gt;{
  },(error)=&gt;{
  });
</code></pre>

<p>批量设置 Todo 已经完成：</p>
<pre><code class="ts">  let query:AV.Query = new AV.Query('Todo');
  query.find&lt;AV.Object []&gt;().then((todos)=&gt;{
    for(let todo of todos){
      todo['status'] = 1;
    }

    AV.Object.saveAll(todos).then(
      (success)=&gt;{
        // 保存成功
    },(error)=&gt;{
    })
  },(error)=&gt;{
  });
</code></pre>

<p>不同类型的批量操作所引发不同数量的 API 调用，具体请参考 <a href="../faq.html#API_调用次数的计算">API 调用次数的计算</a>。</p>
<h3 id="_17">关联数据</h3>
<h4 id="avrelation"><code>AV.Relation</code></h4>
<p>对象可以与其他对象相联系。如前面所述，我们可以把一个 <code>AV.Object</code> 的实例 a，当成另一个 <code>AV.Object</code> 实例 b 的属性值保存起来。这可以解决数据之间一对一或者一对多的关系映射，就像关系型数据库中的主外键关系一样。</p>
<p>例如，一个 TodoFolder 包含多个 Todo ，可以用如下代码实现：</p>
<pre><code class="ts">  let todoFolder : AV.Object = new AV.Object('TodoFolder');
  todoFolder.set('name','工作');
  todoFolder.set('priority',1);

  let todo1 : AV.Object = new AV.Object('Todo');
  todo1.set('title','工程师周会');
  todo1.set('content','每周工程师会议，周一下午2点');
  todo1.set('location','会议室');

  let todo2 : AV.Object = new AV.Object('Todo');
  todo2.set('title','维护文档');
  todo2.set('content','每天 16：00 到 18：00 定期维护文档');
  todo2.set('location','当前工位');

  let todo3 : AV.Object = new AV.Object('Todo');
  todo3.set('title','发布 SDK');
  todo3.set('content','每周一下午 15：00');
  todo3.set('location','SA 工位');

  let localTodos:Array&lt;AV.Object&gt; = [todo1,todo2,todo3];// 构建一个 AV.object 数组
  AV.Object.saveAll&lt;AV.Object []&gt;(localTodos).then(
    (cloudTodos)=&gt;{
      let relation: AV.Relation = todoFolder.relation('containedTodos');// 创建 AV.Relation
      for(let todo of cloudTodos){
        relation.add(todo);// 建立针对每一个 Todo 的 Relation
      }
      todoFolder.save();// 保存到云端
    },(error)=&gt;{

    });
</code></pre>

<h4 id="pointer">Pointer</h4>
<p>Pointer 只是个描述并没有具象的类与之对应，它与 <code>AV.Relation</code> 不一样的地方在于：<code>AV.Relation</code> 是在<strong>一对多</strong>的「一」这一方（上述代码中的一指 TodoFolder）保存一个 <code>AV.Relation</code> 属性，这个属性实际上保存的是对被关联数据<strong>多</strong>的这一方（上述代码中这个多指 Todo）的一个 Pointer 的集合。而反过来，LeanStorage 也支持在「多」的这一方保存一个指向「一」的这一方的 Pointer，这样也可以实现<strong>一对多</strong>的关系。</p>
<p>简单的说， Pointer 就是一个外键的指针，只是在 LeanCloud 控制台做了显示优化。</p>
<p>现在有一个新的需求：用户可以分享自己的 TodoFolder 到广场上，而其他用户看见可以给与评论，比如某一个宅男分享了自己列出的一个想买的游戏列表（TodoFolder 包含多个游戏名字），而我们用 Comment 对象来保存其他用户的评论以及是否点赞等相关信息，代码如下：</p>
<pre><code class="ts">  let comment : AV.Object = new AV.Object('Comment');// 构建 Comment 对象
  comment.set('like',1);// 如果点了赞就是 1，而点了不喜欢则为 -1，没有做任何操作就是默认的 0
  comment.set('content','这个太赞了！楼主，我也要这些游戏，咱们团购么？');

  // 假设已知被分享的该 TodoFolder 的 objectId 是 5735aae7c4c9710060fbe8b0
  let targetTodoFolder : AV.Object = AV.Object.createWithoutData('TodoFolder','5735aae7c4c9710060fbe8b0');
  comment.set('targetTodoFolder',targetTodoFolder);
  comment.save();//保存到云端
</code></pre>

<p>相关内容可参考 <a href="#关联数据查询">关联数据查询</a>。</p>
<h4 id="_18">地理位置</h4>
<p>地理位置是一个特殊的数据类型，LeanStorage 封装了 <code>AV.GeoPoint</code> 来实现存储以及相关的查询。</p>
<p>首先要创建一个 <code>AV.GeoPoint</code> 对象。例如，创建一个北纬 39.9 度、东经 116.4 度的 <code>AV.GeoPoint</code> 对象（LeanCloud 北京办公室所在地）：</p>
<pre><code class="ts">  // 第一个参数是： latitude ，纬度
  // 第二个参数是： longitude，经度
  let point1 : AV.GeoPoint = new AV.GeoPoint(39.9,116.4);

  // 以下是创建 AV.GeoPoint 对象不同的方法
  let point2 : AV.GeoPoint = new AV.GeoPoint([12.7,72.2]);
  let point3 : AV.GeoPoint = new AV.GeoPoint({latitude: 30, longitude: 30});
</code></pre>

<p>假如，添加一条 Todo 的时候为该 Todo 添加一个地理位置信息，以表示创建时所在的位置：</p>
<pre><code class="ts">  todo.set('whereCreated',point);
</code></pre>

<p>同时请参考 <a href="#地理位置查询">地理位置查询</a>。</p>
<h3 id="_19">数据协议</h3>
<p>很多开发者在使用 LeanStorage 初期都会产生疑惑：客户端的数据类型是如何被云端识别的？
因此，我们有必要重点介绍一下 LeanStorage 的数据协议。</p>
<p>先从一个简单的日期类型入手，比如在 JavaScript 中，默认的日期类型是 <code>Date</code>，下面会详细讲解一个
 <code>Date</code> 是如何被云端正确的按照日期格式存储的。</p>
<p>为一个普通的 <code>AV.Object</code> 的设置一个 <code>Date</code> 的属性，然后调用保存的接口：</p>
<pre><code class="ts">  let testDate : Date = new Date('2016-06-04');
  let testAVObject = new AV.Object('TestClass');
  testAVObject.set('testDate', testDate);
  testAVObject.save();
</code></pre>

<p>JavaScript SDK 在真正调用保存接口之前，会自动的调用一次序列化的方法，将 <code>Date</code> 类型的数据，转化为如下格式的数据：</p>
<pre><code class="json">{
  &quot;__type&quot;: &quot;Date&quot;,
  &quot;iso&quot;: &quot;2015-11-21T18:02:52.249Z&quot;
}
</code></pre>

<p>然后发送给云端，云端会自动进行反序列化，这样自然就知道这个数据类型是日期，然后按照传过来的有效值进行存储。因此，开发者在进阶开发的阶段，最好是能掌握 LeanStorage 的数据协议。如下表介绍的就是一些默认的数据类型被序列化之后的格式：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>序列化之后的格式</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Date</code></td>
<td><code>{"__type": "Date","iso": "2015-11-21T18:02:52.249Z"}</code></td>
</tr>
<tr>
<td><code>Buffer</code></td>
<td><code>{"__type": "Bytes","base64":"utf-8-encoded-string}"</code></td>
</tr>
<tr>
<td><code>Pointer</code></td>
<td><code>{"__type":"Pointer","className":"Todo","objectId":"55a39634e4b0ed48f0c1845c"}</code></td>
</tr>
<tr>
<td><code>AV.Relation</code></td>
<td><code>{"__type": "Relation","className": "Todo"}</code></td>
</tr>
</tbody>
</table>
<h2 id="_20">文件</h2>
<p>文件存储也是数据存储的一种方式，图像、音频、视频、通用文件等等都是数据的载体，另外很多开发者习惯了把复杂对象序列化之后保存成文件（如 <code>.json</code> 或者 <code>.xml</code> )。文件存储在 LeanStorage 中被单独封装成一个 <code>AV.File</code> 来实现文件的上传、下载等操作。</p>
<h3 id="_21">文件上传</h3>
<p>文件的上传指的是开发者调用接口将文件存储在云端，并且返回文件最终的 URL 的操作。</p>
<h4 id="_22">从数据流构建文件</h4>
<p><code>AV.File</code> 支持图片、视频、音乐等常见的文件类型，以及其他任何二进制数据，在构建的时候，传入对应的数据流即可：</p>
<pre><code class="ts">  let data = { base64:'6K+077yM5L2g5Li65LuA5LmI6KaB56C06Kej5oiR77yf'};
  let file : AV.File = new AV.File('resume.txt',data);
  file.save&lt;AV.File&gt;().then((savedFile)=&gt;{
  },(error)=&gt;{
  });

  let bytes = [ 0xBE, 0xEF, 0xCA, 0xFE ];
  let byteArrayFile:AV.File = new AV.File('myfile.txt',bytes);
  byteArrayFile.save();
</code></pre>

<p>上例将文件命名为 <code>resume.txt</code>，这里需要注意两点：</p>
<ul>
<li>不必担心文件名冲突。每一个上传的文件都有惟一的 ID，所以即使上传多个文件名为 <code>resume.txt</code> 的文件也不会有问题。</li>
<li>给文件添加扩展名非常重要。云端通过扩展名来判断文件类型，以便正确处理文件。所以要将一张 PNG 图片存到 <code>AVFile</code> 中，要确保使用 <code>.png</code> 扩展名。</li>
</ul>
<h4 id="_23">从本地路径构建文件</h4>
<p>大多数的客户端应用程序都会跟本地文件系统产生交互，常用的操作就是读取本地文件，如下代码可以实现使用本地文件路径构建一个 <code>AV.File</code>：</p>
<p>假设在页面上有如下文件选择框：</p>
<pre><code class="html">&lt;input type=&quot;file&quot; id=&quot;photoFileUpload&quot;/&gt;
</code></pre>

<p>上传文件对应的代码如下：</p>
<pre><code class="js">    var fileUploadControl = $('#photoFileUpload')[0];
    if (fileUploadControl.files.length &gt; 0) {
      var file = fileUploadControl.files[0];
      var name = 'avatar.jpg';

      var avFile = new AV.File(name, file);
      avFile.save().then(function(obj) {
        // 数据保存成功
        console.log(obj.url());
      }, function(error) {
        // 数据保存失败
        console.log(error);
      });
    }
</code></pre>

<h4 id="_24">从网络路径构建文件</h4>
<p>从一个已知的  构建文件也是很多应用的需求，例如，从网页上拷贝了一个图像的链接，希望 SDK 能够读取并且上传到自己的应用内，之后的使用中不必担心原网址失效，而造成 UI 的缺失。</p>
<pre><code class="ts">  let file : AV.File = AV.File.withURL('Satomi_Ishihara.gif','http://ww3.sinaimg.cn/bmiddle/596b0666gw1ed70eavm5tg20bq06m7wi.gif');
  file.save&lt;AV.File&gt;().then((savedFile)=&gt;{
  },(error)=&gt;{
  });
</code></pre>

<p>我们需要做出说明的是，<a href="#从本地路径构建文件">从本地路径构建文件</a> 会<u>产生实际上传的流量</u>，并且文件最后是存在云端，而 <a href="#从网络路径构建文件">从网络路径构建文件</a> 的文件实体并不存储在云端，只是会把文件的物理地址作为一个字符串保存在云端。</p>
<h4 id="_25">执行上传</h4>
<p>上传的操作调用方法如下：</p>
<p>如果仅是想简单的上传，可以直接在 Web 前端使用 AV.File 上面的相关方法。但真实使用场景中，还有很多开发者需要自行实现一个上传接口，对数据做更多的处理。</p>
<p>以下是一个在 Web 中完整上传一张图片的 Demo，包括前端与 Node.js 服务端代码。服务端推荐使用 LeanCloud 推出的「<a href="../leanengine_overview.html">云引擎</a>」，非常出色的 Node.js 环境。</p>
<p>前端页面（比如:fileUpload.html）：</p>
<pre><code class="html">// 页面元素（限制上传为图片类型，使用时可自行修改 accept 属性）
&lt;form id=&quot;upload-file-form&quot; class=&quot;upload&quot; enctype=&quot;multipart/form-data&quot;&gt;
  &lt;input name=&quot;attachment&quot; type=&quot;file&quot; accept=&quot;image/gif, image/jpeg, image/png&quot;&gt;
&lt;/form&gt;
</code></pre>

<p>纯前端调用方式：</p>
<pre><code class="javascript">// 前端代码，基于 jQuery
function uploadPhoto() {
  var uploadFormDom = $('#upload-file-form');
  var uploadInputDom = uploadFormDom.find('input[type=file]');
  // 获取浏览器 file 对象
  var files = uploadInputDom[0].files;
  // 创建 formData 对象
  var formData = new window.FormData(uploadFormDom[0]);
  if (files.length) {
    $.ajax({
      // 注意，这个 url 地址是一个例子，真实使用时需替换为自己的上传接口 url
      url: 'https://leancloud.cn/xxx/xxx/upload',
      method: 'post',
      data: formData,
      processData: false,
      contentType: false
    }).then((data) =&gt; {
      // 上传成功，服务端设置返回
      console.log(data);
    });
  }
};
</code></pre>

<p>在服务端可以编写如下代码：</p>
<pre><code class="javascript">// 服务端代码，基于 Node.js、Express
var AV = require('leanengine');
// 服务端需要使用 connect-busboy（通过 npm install 安装）
var busboy = require('connect-busboy');
// 使用这个中间件
app.use(busboy());

// 上传接口方法（使用时自行配置到 router 中）
function uploadFile (req, res) {
  if (req.busboy) {
    var base64data = [];
    var pubFileName = '';
    var pubMimeType = '';
    req.busboy.on('file', (fieldname, file, fileName, encoding, mimeType) =&gt; {
      var buffer = '';
      pubFileName = fileName;
      pubMimeType = mimeType;
      file.setEncoding('base64');
      file.on('data', function(data) {
        buffer += data;
      }).on('end', function() {
        base64data.push(buffer);
      });
    }).on('finish', function() {
      var f = new AV.File(pubFileName, {
        // 仅上传第一个文件（多个文件循环创建）
        base64: base64data[0]
      });
      try {
        f.save().then(function(fileObj) {
          // 向客户端返回数据
          res.send({
            fileId: fileObj.id,
            fileName: fileObj.name(),
            mimeType: fileObj.metaData().mime_type,
            fileUrl: fileObj.url()
          });
        });
      } catch (error) {
        console.log('uploadFile - ' + error);
        res.status(502);
      }
    })
    req.pipe(req.busboy);
  } else {
    console.log('uploadFile - busboy undefined.');
    res.status(502);
  }
};
</code></pre>

<h3 id="_26">图像缩略图</h3>
<p>保存图像时，如果想在下载原图之前先得到缩略图，方法如下：</p>
<pre><code class="ts">  //获得宽度为100像素，高度200像素的缩略图
  let thumbnailURL = file.thumbnailURL(100,200);
</code></pre>

<h3 id="_27">文件元数据</h3>
<p><code>AVFile</code> 的 <code>metaData</code> 属性，可以用来保存和获取该文件对象的元数据信息：</p>
<pre><code class="ts">  // 获取文件大小
  let size = file.size();
  // 上传者(AV.User) 的 objectId，如果未登录，默认为空
  let ownerId = file.ownerId();

  // 获取文件的全部元信息
  let metadata = file.metaData();
  // 设置文件的作者
  file.metaData('author','LeanCloud');
  // 获取文件的格式
  let format = file.metaData('format');
</code></pre>

<h3 id="_28">删除</h3>
<p>当文件较多时，要把一些不需要的文件从云端删除：</p>
<pre><code class="ts">  let file:AV.File = AV.File.createWithoutData('552e0a27e4b0643b709e891e');
  file.destroy().then((success)=&gt;{
  },(error)=&gt;{
  });
</code></pre>

<div class="callout callout-info">注意：默认情况下，文件的删除权限是关闭的，需要进入控制台，在 [`_File` > 其他 > 权限设置 > delete](/data.html?appid={{appid}}#/_File)  中开启。</div>

<h2 id="_29">查询</h2>
<p><code>AV.Query</code> 是构建针对 <code>AV.Object</code> 查询的基础类。</p>
<h3 id="_30">创建查询实例</h3>
<pre><code class="ts">  let query: AV.Query= new AV.Query('Todo');
</code></pre>

<h3 id="id">根据 id 查询</h3>
<p>在<a href="#获取对象">获取对象</a>中我们介绍过如何通过 objectId 来获取对象实例，从而简单的介绍了一下 AV.Query 的用法，代码请参考对应的内容，不再赘述。</p>
<h3 id="_31">条件查询</h3>
<p>在大多数情况下做列表展现的时候，都是根据不同条件来分类展现的，比如，我要查询所有优先级为 0 的 Todo，也就是做列表展现的时候，要展示优先级最高，最迫切需要完成的日程列表，此时基于 priority 构建一个查询就可以查询出符合需求的对象：</p>
<pre><code class="ts">  let query: AV.Query= new AV.Query('Todo');
  // 查询 priority 是 0 的 Todo
  query.equalTo('priority',0);
  query.find&lt;AV.Object []&gt;().then((results)=&gt;{
    let priorityEqualsZeroTodos : Array&lt;AV.Object&gt; =results;
  },(error)=&gt;{

  });
</code></pre>

<p>其实，拥有传统关系型数据库开发经验的开发者完全可以翻译成如下的 SQL：</p>
<pre><code class="sql">  select * from Todo where priority = 0
</code></pre>

<p>LeanStorage 也支持使用这种传统的 SQL 语句查询。具体使用方法请移步至 <a href="#CQL_查询">Cloud Query Language（CQL）查询</a>。</p>
<p>查询默认最多返回 100 条符合条件的结果，要更改这一数值，请参考 <a href="#限定返回数量">限定结果返回数量</a>。</p>
<p>当多个查询条件并存时，它们之间默认为 AND 关系，即查询只返回满足了全部条件的结果。建立 OR 关系则需要使用 <a href="#复合查询">复合查询</a>。</p>
<p>注意：在简单查询中，如果对一个对象的同一属性设置多个条件，那么先前的条件会被覆盖，查询只返回满足最后一个条件的结果。例如，我们要找出优先级为 0 和 1 的所有 Todo，错误写法是：</p>
<pre><code class="ts">  let query: AV.Query= new AV.Query('Todo');
  query.equalTo('priority',0);
  query.equalTo('priority',1);
  query.find&lt;AV.Object []&gt;().then((results)=&gt;{
    // 如果这样写，第二个条件将覆盖第一个条件，查询只会返回 priority = 1 的结果
  },(error)=&gt;{
  });
</code></pre>

<p>正确作法是使用 <a href="#OR_查询">OR 关系</a> 来构建条件。</p>
<h4 id="_32">比较查询</h4>
<table>
<thead>
<tr>
<th>逻辑操作</th>
<th>AVQuery 方法</th>
</tr>
</thead>
<tbody>
<tr>
<td>等于</td>
<td><code>equalTo</code></td>
</tr>
<tr>
<td>不等于</td>
<td><code>notEqualTo</code></td>
</tr>
<tr>
<td>大于</td>
<td><code>greaterThan</code></td>
</tr>
<tr>
<td>大于等于</td>
<td><code>greaterThanOrEqualTo</code></td>
</tr>
<tr>
<td>小于</td>
<td><code>lessThan</code></td>
</tr>
<tr>
<td>小于等于</td>
<td><code>lessThanOrEqualTo</code></td>
</tr>
</tbody>
</table>
<p>利用上述表格介绍的逻辑操作的接口，我们可以很快地构建条件查询。</p>
<p>例如，查询优先级小于 2 的所有 Todo ：</p>
<pre><code class="ts">  let query: AV.Query= new AV.Query('Todo');
  query.lessThan('priority',2);
</code></pre>

<p>要查询优先级大于等于 2 的 Todo：</p>
<pre><code class="ts">  query.greaterThanOrEqualTo('priority',2);
</code></pre>

<p>比较查询<strong>只适用于可比较大小的数据类型</strong>，如整型、浮点等。</p>
<h4 id="_33">正则匹配查询</h4>
<p>正则匹配查询是指在查询条件中使用正则表达式来匹配数据，查询指定的 key 对应的 value 符合正则表达式的所有对象。
例如，要查询标题包含中文的 Todo 对象可以使用如下代码：</p>
<pre><code class="ts">  let query: AV.Query= new AV.Query('Todo');
  let regExp : RegExp = new RegExp('[\u4e00-\u9fa5]','i');
  query.matches('title',regExp);
  query.find&lt;AV.Object []&gt;().then((results)=&gt;{
  },(error)=&gt;{
  });
</code></pre>

<p>正则匹配查询<strong>只适用于</strong>字符串类型的数据。</p>
<h4 id="_34">包含查询</h4>
<p>包含查询类似于传统 SQL 语句里面的 <code>LIKE %keyword%</code> 的查询，比如查询标题包含「李总」的 Todo：</p>
<pre><code class="ts">  query.contains('title','李总');
</code></pre>

<p>翻译成 SQL 语句就是：</p>
<pre><code class="sql">  select * from Todo where title LIKE '%李总%'
</code></pre>

<p>不包含查询与包含查询是对立的，不包含指定关键字的查询，可以使用 <a href="#正则匹配查询">正则匹配方法</a> 来实现。例如，查询标题不包含「机票」的 Todo：</p>
<pre><code class="ts">  let query: AV.Query= new AV.Query('Todo');
  let regExp : RegExp = new RegExp('^((?!机票).)*$','i');
  query.matches('title',regExp);
</code></pre>

<p>但是基于正则的模糊查询有两个缺点：</p>
<ul>
<li>当数据量逐步增大后，查询效率将越来越低。</li>
<li>没有文本相关性排序</li>
</ul>
<p>因此，你还可以考虑使用 <a href="#应用内搜索">应用内搜索</a> 功能。它基于搜索引擎技术构建，提供更强大的搜索功能。</p>
<p>还有一个接口可以精确匹配不等于，比如查询标题不等于「出差、休假」的 Todo 对象：</p>
<pre><code class="ts">  let query: AV.Query= new AV.Query('Todo');
  let filterArray : Array&lt;string&gt; = ['出差','休假'];
  query.notContainedIn('title',filterArray);
</code></pre>

<h4 id="_35">数组查询</h4>
<p>当一个对象有一个属性是数组的时候，针对数组的元数据查询可以有多种方式。例如，在 <a href="#更新数组">数组</a> 一节中我们为 Todo 设置了 reminders 属性，它就是一个日期数组，现在我们需要查询所有在 8:30 会响起闹钟的 Todo 对象：</p>
<pre><code class="ts">  let query: AV.Query= new AV.Query('Todo');
  let reminderFilter: Array&lt;Date&gt; = [new Date('2015-11-11 08:30:00')];
  query.containsAll('reminders',reminderFilter);

  // 也可以使用 equals 接口实现这一需求
  let targetDateTime : Date =  new Date('2015-11-11 08:30:00');
  query.equalTo('reminders',targetDateTime);
</code></pre>

<p>如果你要查询包含 8:30、9:30 这两个时间点响起闹钟的 Todo，可以使用如下代码：</p>
<pre><code class="ts">  let query: AV.Query= new AV.Query('Todo');
  let reminderFilter: Array&lt;Date&gt; = [new Date('2015-11-11 08:30:00'),new Date('2015-11-11 09:30:00')];
  query.equalTo('reminders',reminderFilter);
</code></pre>

<p>注意这里是包含关系，假如有一个 Todo 会在 8:30、9:30、10:30 响起闹钟，它仍然是会被查询出来的。</p>
<h4 id="_36">字符串查询</h4>
<p>使用 <code>startsWith</code> 可以过滤出以特定字符串开头的结果，这有点像 SQL 的 LIKE 条件。因为支持索引，所以该操作对于大数据集也很高效。</p>
<pre><code class="ts">  // 找出开头是「早餐」的 Todo
  let query: AV.Query= new AV.Query('Todo');
  query.startsWith('content','早餐');
</code></pre>

<h4 id="_37">空值查询</h4>
<p>假设我们的 Todo 允许用户上传图片用来帮助用户记录某些特殊的事项，但是有时候用户可能就记得自己给一个 Todo 附加过图片，但是具体又不记得这个 Todo 的关键字是什么，因此我们需要一个接口可以找出那些有图片的 Todo，此时就可以使用到空值查询的接口：</p>
<pre><code class="ts">  let aTodoAttachmentImage : AV.File = AV.File.withURL('attachment.jpg','http://www.zgjm.org/uploads/allimg/150812/1_150812103912_1.jpg');
  let todo: AV.Object = new AV.Object('Todo');
  todo.set('images',aTodoAttachmentImage);
  todo.set('content','记得买过年回家的火车票！！！');
  todo.save();

  let query : AV.Query = new AV.Query('Todo');
  query.exists('images');
  query.find&lt;AV.Object []&gt;().then((results)=&gt;{
    // results 返回的就是有图片的 Todo 集合
  },(error)=&gt;{

  });

  // 使用空值查询获取没有图片的 Todo
  query.doesNotExist('images');
</code></pre>

<h3 id="_38">组合查询</h3>
<p>组合查询就是把诸多查询条件合并成一个查询，再交给 SDK 去云端查询。方式有两种：OR 和 AND。</p>
<h4 id="or">OR 查询</h4>
<p>OR 操作表示多个查询条件符合其中任意一个即可。 例如，查询优先级是大于等于 3 或者已经完成了的 Todo：</p>
<pre><code class="ts">  let priorityQuery: AV.Query = new AV.Query('Todo');
  priorityQuery.greaterThanOrEqualTo('priority',3);

  let statusQuery: AV.Query = new AV.Query('Todo');
  statusQuery.equalTo('status',1);

  let query : AV.Query =  AV.Query.or(priorityQuery,statusQuery);
  // 返回 priority 大于等于 3 或 status 等于 1 的 Todo
</code></pre>

<p><strong>注意：OR 查询中，子查询中不能包含地理位置相关的查询。</strong></p>
<h4 id="and">AND 查询</h4>
<p>AND 操作是指只有满足了所有查询条件的对象才会被返回给客户端。例如，查询优先级小于 1 并且尚未完成的 Todo：</p>
<pre><code class="ts">  let priorityQuery: AV.Query = new AV.Query('Todo');
  priorityQuery.greaterThanOrEqualTo('priority',3);

  let statusQuery: AV.Query = new AV.Query('Todo');
  statusQuery.equalTo('status',1);

  let query : AV.Query =  AV.Query.and(priorityQuery,statusQuery);
  // 返回 priority 小于 3 并且 status 等于 0 的 Todo
</code></pre>

<p>可以对新创建的 <code>AV.Query</code> 添加额外的约束，多个约束将以 AND 运算符来联接。</p>
<h3 id="_39">查询结果</h3>
<h4 id="_40">获取第一条结果</h4>
<p>例如很多应用场景下，只要获取满足条件的一个结果即可，例如获取满足条件的第一条 Todo：</p>
<pre><code class="ts">  let query: AV.Query = new AV.Query('Comment');
  query.equalTo('priority',0);
  query.first&lt;AV.Object&gt;().then((data)=&gt;{
    // data 就是符合条件的第一个 AV.Object
  },(error)=&gt;{
  });
</code></pre>

<h4 id="_41">限定返回数量</h4>
<p>为了防止查询出来的结果过大，云端默认针对查询结果有一个数量限制，即 <code>limit</code>，它的默认值是 100。比如一个查询会得到 10000 个对象，那么一次查询只会返回符合条件的 100 个结果。<code>limit</code> 允许取值范围是 1 ~ 1000。例如设置返回 10 条结果：</p>
<pre><code class="ts">  let query: AV.Query = new AV.Query('Todo');
  let now : Date = new Date();
  query.lessThanOrEqualTo('createdAt',now);//查询今天之前创建的 Todo
  query.limit(10);// 最多返回 10 条结果
</code></pre>

<h4 id="_42">跳过数量</h4>
<p>设置 skip 这个参数可以告知云端本次查询要跳过多少个结果。将 skip 与 limit 搭配使用可以实现翻页效果，这在客户端做列表展现时，尤其在数据量庞大的情况下就使用技术。例如，在翻页中，一页显示的数量是 10 个，要获取第 3 页的对象：</p>
<pre><code class="ts">  let query: AV.Query = new AV.Query('Todo');
  let now : Date = new Date();
  query.lessThanOrEqualTo('createdAt',now);//查询今天之前创建的 Todo
  query.limit(10);// 最多返回 10 条结果
  query.skip(20);  // 跳过 20 条结果
</code></pre>

<p>尽管我们提供以上接口，但是我们不建议广泛使用，因为它的执行效率比较低。取而代之，我们建议使用 <code>createdAt</code> 或者 <code>updatedAt</code> 这类的时间戳进行分段查询。</p>
<h4 id="_43">属性限定</h4>
<p>通常列表展现的时候并不是需要展现某一个对象的所有属性，例如，Todo 这个对象列表展现的时候，我们一般展现的是 title 以及 content，我们在设置查询的时候，也可以告知云端需要返回的属性有哪些，这样既满足需求又节省了流量，也可以提高一部分的性能，代码如下：</p>
<pre><code class="ts">  let query: AV.Query = new AV.Query('Todo');
  // 指定返回的属性
  query.select('title','content');
  query.find&lt;AV.Object []&gt;().then((results)=&gt;{
    for(let todo of results){
      let title = todo.get('title');
      let content = todo.get('content');

      // 如果访问没有指定返回的属性（key），则会报错，在当前这段代码中访问 location 属性就会报错
      let location = todo.get('location');
    }
  },(error)=&gt;{

  });
</code></pre>

<h4 id="_44">统计总数量</h4>
<p>通常用户在执行完搜索后，结果页面总会显示出诸如「搜索到符合条件的结果有 1020 条」这样的信息。例如，查询一下今天一共完成了多少条 Todo：</p>
<pre><code class="ts">  let query: AV.Query = new AV.Query('Todo');
  query.equalTo('status',1);
  query.count&lt;number&gt;().then((count)=&gt;{
    console.log(count);
  },(error)=&gt;{

  });
</code></pre>

<h4 id="_45">排序</h4>
<p>对于数字、字符串、日期类型的数据，可对其进行升序或降序排列。</p>
<pre><code class="ts">  // 按时间，升序排列
  query.ascending('createdAt');

  // 按时间，降序排列
  query.descending('createdAt');
</code></pre>

<p>一个查询可以附加多个排序条件，如按 priority 升序、createdAt 降序排列：</p>
<pre><code class="ts">  let query: AV.Query = new AV.Query('Todo');
  query.ascending('priority');
  query.descending('createdAt');
</code></pre>

<!-- #### 限定返回字段 -->

<h3 id="_46">关系查询</h3>
<p>关联数据查询也可以通俗地理解为关系查询，关系查询在传统型数据库的使用中是很常见的需求，因此我们也提供了相关的接口来满足开发者针对关联数据的查询。</p>
<p>首先，我们需要明确关系的存储方式，再来确定对应的查询方式。</p>
<h4 id="pointer_1">Pointer 查询</h4>
<p>基于在 <a href="#Pointer">Pointer</a> 小节介绍的存储方式：每一个 Comment 都会有一个 TodoFolder 与之对应，用以表示 Comment 属于哪个 TodoFolder。现在我已知一个 TodoFolder，想查询所有的 Comnent 对象，可以使用如下代码：</p>
<pre><code class="ts">  let query: AV.Query= new AV.Query('Comment');
  let todoFolder : AV.Object = AV.Object.createWithoutData('Todo','5735aae7c4c9710060fbe8b0');
  query.equalTo('targetTodoFolder',todoFolder);
</code></pre>

<h4 id="avrelation_1"><code>AV.Relation</code> 查询</h4>
<p>假如用户可以给 TodoFolder 增加一个 Tag 选项，用以表示它的标签，而为了以后拓展 Tag 的属性，就新建了一个 Tag 对象，如下代码是创建 Tag 对象：</p>
<pre><code class="ts">  let tag: AV.Object= new AV.Object('Todo');
  tag.set('name','今日必做');
  tag.save();
</code></pre>

<p>而 Tag 的意义在于一个 TodoFolder 可以拥有多个 Tag，比如「家庭」（TodoFolder） 拥有的 Tag 可以是：今日必做，老婆吩咐，十分重要。实现创建「家庭」这个 TodoFolder 的代码如下：</p>
<pre><code class="ts">  let tag1: AV.Object= new AV.Object('Todo');
  tag1.set('name','今日必做');

  let tag2: AV.Object= new AV.Object('Todo');
  tag2.set('name','老婆吩咐');

  let tag3: AV.Object= new AV.Object('Todo');
  tag3.set('name','十分重要');

  let tags:Array&lt;AV.Object&gt; = [tag1,tag2,tag3];

  AV.Object.saveAll&lt;AV.Object []&gt;(tags).then((savedTags)=&gt;{
    let todoFolder:AV.Object = new AV.Object('TodoFolder');
    todoFolder.set('name','家庭');
    todoFolder.set('priority',1);

    let relation : AV.Relation = todoFolder.relation('tags');
    relation.add(tag1);
    relation.add(tag2);
    relation.add(tag3);

    todoFolder.save();
  },(error)=&gt;{

  });
</code></pre>

<p>查询一个 TodoFolder 的所有 Tag 的方式如下：</p>
<pre><code class="ts">  let todoFolder : AV.Object = AV.Object.createWithoutData('Todo','5735aae7c4c9710060fbe8b0');
  let relation : AV.Relation = todoFolder.relation('tags');
  let query : AV.Query = relation.query();
  query.find&lt;AV.Object []&gt;().then((results)=&gt;{
    // results 是一个 AV.Object 的数组，它包含所有当前 todoFolder 的 tags
  },(error)=&gt;{

  });
</code></pre>

<p>反过来，现在已知一个 Tag，要查询有多少个 TodoFolder 是拥有这个 Tag 的，可以使用如下代码查询：</p>
<pre><code class="ts">  let targetTag : AV.Object = AV.Object.createWithoutData('Tag','5655729900b0bf3785ca8192');
  let query: AV.Query= new AV.Query('TodoFolder');
  query.equalTo('tags',targetTag);
  query.find&lt;AV.Object []&gt;().then((results)=&gt;{
    // results 是一个 AV.Object 的数组
    // results 指的就是所有包含当前 tag 的 TodoFolder
  },(error)=&gt;{

  });
</code></pre>

<p>关于关联数据的建模是一个复杂的过程，很多开发者因为在存储方式上的选择失误导致最后构建查询的时候难以下手，不但客户端代码冗余复杂，而且查询效率低，为了解决这个问题，我们专门针对关联数据的建模推出了一个详细的文档予以介绍，详情请点击：<a href="../relation_guide-js.html">JavaScript 关系建模指南</a></p>
<h4 id="_47">关联属性查询</h4>
<p>正如在 <a href="#Pointer">Pointer</a> 中保存 Comnent 的 targetTodoFolder 属性一样，假如查询到了一些 Comment 对象，想要一并查询出每一条 Comment 对应的 TodoFolder 对象的时候可以使用如下代码：</p>
<pre><code class="ts">  let commentQuery: AV.Query = new AV.Query('Comment');
  commentQuery.descending('createdAt');
  commentQuery.limit(10);
  commentQuery.include('targetTodoFolder');// 关键代码，用 includeKey 告知服务端需要返回的关联属性对应的对象的详细信息，而不仅仅是 objectId
  commentQuery.find&lt;AV.Object []&gt;().then((comments)=&gt;{
    // comments 是最近的十条评论, 其 targetTodoFolder 字段也有相应数据
    for(let comment of comments){
      // 并不需要网络访问
      let todoFolder = comment.get('targetTodoFolder');
    }
  },(error)=&gt;{

  });
</code></pre>

<h4 id="_48">内嵌查询</h4>
<p>假如现在有一个需求是展现点赞超过 20 次的 TodoFolder 的评论（Comment）查询出来，注意这个查询是针对评论（Comment），要实现一次查询就满足需求可以使用内嵌查询的接口：</p>
<pre><code class="ts">  // 构建内嵌查询
  let innerQuery: AV.Query = new AV.Query('TodoFolder');
  innerQuery.greaterThan('likes',20);

  // 将内嵌查询赋予目标查询
  let query: AV.Query = new AV.Query('Comment');

  // 执行内嵌操作
  query.matchesQuery('targetTodoFolder',innerQuery);

  query.find&lt;AV.Object []&gt;().then((results)=&gt;{
    // results 就是符合超过 20 个赞的 TodoFolder 这一条件的 Comment 对象集合
  },(error)=&gt;{

  });

  query.doesNotMatchQuery('targetTodoFolder',innerQuery);
  // 如此做将查询出 likes 小于或者等于 20 的 TodoFolder 的 Comment 对象
</code></pre>

<h3 id="cql_3">CQL 查询</h3>
<p>Cloud Query Language（CQL）是 LeanStorage 独创的使用类似 SQL 语法来实现云端查询功能的语言，具有 SQL 开发经验的开发者可以方便地使用此接口实现查询。</p>
<p>分别找出 status = 1 的全部 Todo 结果，以及 priority = 0 的 Todo 的总数：</p>
<pre><code class="ts">  let cql : string = 'select * from %@ where status = 1';
  AV.Query.doCloudQuery&lt;any&gt;(cql).then((data)=&gt;{
    let results = data.results;
    // results 即为查询结果，它是一个 AV.Object 数组
  },(error)=&gt;{

  });

  cql  = 'select * from %@ where status = 1';
  AV.Query.doCloudQuery&lt;any&gt;(cql).then((data)=&gt;{
     let count = data.count;
     // count 是 number 类型
  },(error)=&gt;{

  });
</code></pre>

<p>通常，查询语句会使用变量参数。为此，我们提供了与 Java JDBC 所使用的 PreparedStatement 占位符查询相类似的语法结构。</p>
<p>查询 status = 0、 priority = 1 的 Todo：</p>
<pre><code class="ts">  // 带有占位符的 cql 语句
  let cql : string = 'select * from %@ where status = ? and priority = ?';
  let pvalues = [0,1];
  AV.Query.doCloudQuery&lt;any&gt;(cql,pvalues).then((data)=&gt;{
     let results = data.results;
     // results 即为查询结果，它是一个 AV.Object 数组
  },(error)=&gt;{

  });
</code></pre>

<p>目前 CQL 已经支持数据的更新（update），插入（insert），删除（delete）等 SQL 语法，更多内容请参考 <a href="../cql_guide.html">Cloud Query Language 详细指南</a>。</p>
<h3 id="_49">地理位置查询</h3>
<p>地理位置查询是较为特殊的查询，一般来说，常用的业务场景是查询距离 xx 米之内的某个位置或者是某个建筑物，甚至是以手机为圆心，查找方圆多少范围内餐厅，诸如此类，对此，LeanStorage 提供了一系列的方法来实现各种针对地理位置的查询。</p>
<h4 id="_50">查询位置附近的对象</h4>
<p>Todo 的 <code>whereCreated</code>（创建 Todo 时的位置）是一个 <code>AV.GeoPoint</code> 对象，现在已知了一个地理位置，现在要查询 <code>whereCreated</code> 靠近这个位置的 Todo 对象可以使用如下代码：</p>
<pre><code class="ts">  let query : AV.Query = new AV.Query('Todo');
  let point : AV.GeoPoint = new AV.GeoPoint('39.9','116.4');
  query.withinKilometers('whereCreated',point,2.0);
  query.find&lt;AV.Object []&gt;().then((results)=&gt;{
    let nearbyTodos : AV.Object [] = results;
  },(error)=&gt;{
  });
</code></pre>

<p>在上面的代码中，<code>nearbyTodos</code> 返回的是与 <code>point</code> 这一点按距离排序（由近到远）的对象数组。注意：<strong>如果在此之后又使用了 <code>ascending</code> 或 <code>descending</code> 方法，则按距离排序会被新排序覆盖。</strong></p>
<h4 id="_51">查询指定范围内的对象</h4>
<p>要查找指定距离范围内的数据，可使用 <code>whereWithinKilometers</code> 、 <code>whereWithinMiles</code> 或 <code>whereWithinRadians</code> 方法。
例如，我要查询距离指定位置，2 千米范围内的 Todo：</p>
<pre><code class="ts">  let query : AV.Query = new AV.Query('Todo');
  let point : AV.GeoPoint = new AV.GeoPoint('39.9','116.4');
  query.withinKilometers('whereCreated',point,2.0);
</code></pre>

<h4 id="_52">注意事项</h4>
<p>使用地理位置需要注意以下方面：</p>
<ul>
<li>每个 <code>AV.Object</code> 数据对象中只能有一个 <code>AV.GeoPoint</code> 对象的属性。</li>
<li>地理位置的点不能超过规定的范围。纬度的范围应该是在 <code>-90.0</code> 到 <code>90.0</code> 之间，经度的范围应该是在 <code>-180.0</code> 到 <code>180.0</code> 之间。如果添加的经纬度超出了以上范围，将导致程序错误。</li>
</ul>
<h2 id="promise">Promise</h2>
<p>除了回调函数之外，每一个在 LeanCloud JavaScript SDK 中的异步方法都会返回一个
 <code>Promise</code>。使用 <code>Promise</code>，你的代码可以比原来的嵌套 callback 的方法看起来优雅得多。</p>
<pre><code class="javascript">// 这是一个比较完整的例子，具体方法可以看下面的文档
// 查询某个 AV.Object 实例，之后进行修改
var query = new AV.Query('TestObject');
query.equalTo('name', 'hjiang');
// find 方法是一个异步方法，会返回一个 Promise，之后可以使用 then 方法
query.find().then(function(results) {
  // 返回一个符合条件的 list
  var obj = results[0];
  obj.set('phone', '182xxxx5548');
  // save 方法也是一个异步方法，会返回一个 Promise，所以在此处，你可以直接 return 出去，后续操作就可以支持链式 Promise 调用
  return obj.save();
}).then(function() {
  // 这里是 save 方法返回的 Promise
  console.log('设置手机号码成功');
}).catch(function(error) {
  // catch 方法写在 Promise 链式的最后，可以捕捉到全部 error
  console.log(error);
});
</code></pre>

<h3 id="then">then 方法</h3>
<p>每一个 Promise 都有一个叫 <code>then</code> 的方法，这个方法接受一对 callback。第一个 callback 在 promise 被解决（<code>resolved</code>，也就是正常运行）的时候调用，第二个会在 promise 被拒绝（<code>rejected</code>，也就是遇到错误）的时候调用。</p>
<pre><code class="javascript">obj.save().then(function(obj) {
  //对象保存成功
}, function(error) {
  //对象保存失败，处理 error
});
</code></pre>

<p>其中第二个参数是可选的。</p>
<h3 id="trycatch-finally">try、catch 和 finally 方法</h3>
<p>你还可以使用 <code>try,catch,finally</code> 三个方法，将逻辑写成：</p>
<pre><code class="javascript">obj.save().try(function(obj) {
  //对象保存成功
}).catch(function(error) {
  //对象保存失败，处理 error
}).finally(function(){
  //无论成功还是失败，都调用到这里
});
</code></pre>

<p>类似语言里的 <code>try ... catch ... finally</code> 的调用方式来简化代码。</p>
<p>为了兼容其他 Promise 库，我们提供了下列别名：</p>
<ul>
<li><code>AV.Promise#done</code> 等价于 <code>try</code> 方法</li>
<li><code>AV.Promise#fail</code> 等价于 <code>catch</code> 方法</li>
<li><code>AV.Promise#always</code> 等价于 <code>finally</code> 方法</li>
</ul>
<p>因此上面例子也可以写成：</p>
<pre><code class="javascript">obj.save().done(function(obj) {
  //对象保存成功
}).fail(function(error) {
  //对象保存失败，处理 error
}).always(function(){
  //无论成功还是失败，都调用到这里
});
</code></pre>

<h3 id="promise_1">将 Promise 组织在一起</h3>
<p>Promise 比较神奇，可以代替多层嵌套方式来解决发送异步请求代码的调用顺序问题。如果一个 Promise 的回调会返回一个 Promise，那么第二个 then 里的 callback 在第一个 then
的 callback 没有解决前是不会解决的，也就是所谓 <strong>Promise Chain</strong>。</p>
<pre><code class="javascript">var query = new AV.Query('Student');
query.addDescending('gpa');
query.find().then(function(students) {
  students[0].set('valedictorian', true);
  return students[0].save();

}).then(function(valedictorian) {
  return query.find();

}).then(function(students) {
  students[1].set('salutatorian', true);
  return students[1].save();

}).then(function(salutatorian) {
  // Everything is done!

});
</code></pre>

<h3 id="_53">错误处理</h3>
<p>如果任意一个在链中的 Promise 返回一个错误的话，所有的成功的 callback 在接下
来都会被跳过直到遇到一个处理错误的 callback。</p>
<p>处理 error 的 callback 可以转换 error 或者可以通过返回一个新的 Promise 的方式来处理它。你可以想象成拒绝的 promise 有点像抛出异常，而 error callback 函数则像是一个 catch 来处理这个异常或者重新抛出异常。</p>
<pre><code class="javascript">var query = new AV.Query('Student');
query.addDescending('gpa');
query.find().then(function(students) {
  students[0].set('valedictorian', true);
  // 强制失败
  return AV.Promise.error('There was an error.');

}).then(function(valedictorian) {
  // 这里的代码将被忽略
  return query.find();

}).then(function(students) {
  // 这里的代码也将被忽略
  students[1].set('salutatorian', true);
  return students[1].save();
}, function(error) {
  // 这个错误处理函数将被调用，并且错误信息是 'There was an error.'.
  // 让我们处理这个错误，并返回一个“正确”的新 Promise
  return AV.Promise.as('Hello!');

}).then(function(hello) {
  // 最终处理结果
}, function(error) {
  // 这里不会调用，因为前面已经处理了错误
});
</code></pre>

<p>通常来说，在正常情况的回调函数链的末尾，加一个错误处理的回调函数，是一种很
常见的做法。</p>
<p>利用 <code>try,catch</code> 方法可以将上述代码改写为：</p>
<pre><code class="javascript">var query = new AV.Query('Student');
query.addDescending('gpa');
query.find().try(function(students) {
  students[0].set('valedictorian', true);
  // 强制失败
  return AV.Promise.error('There was an error.');

}).try(function(valedictorian) {
  // 这里的代码将被忽略
  return query.find();

}).try(function(students) {
  // 这里的代码也将被忽略
  students[1].set('salutatorian', true);
  return students[1].save();

}).catch(function(error) {
  // 这个错误处理函数将被调用，并且错误信息是 'There was an error.'.
  // 让我们处理这个错误，并返回一个“正确”的新 Promise
  return AV.Promise.as('Hello!');
}).try(function(hello) {
  // 最终处理结果
}).catch(function(error) {
  // 这里不会调用，因为前面已经处理了错误
});
</code></pre>

<h3 id="promise_2">创建 Promise</h3>
<p>在开始阶段,你可以只用系统（譬如 find 和 save 方法等）返回的 promise。但是，在更高级
的场景下，你可能需要创建自己的 promise。在创建了 Promise 之后，你需要调用 <code>resolve</code> 或者 <code>reject</code> 来触发它的 callback.</p>
<pre><code class="javascript">var successful = new AV.Promise();
successful.resolve('The good result.');

var failed = new AV.Promise();
failed.reject('An error message.');
</code></pre>

<p>如果你在创建 promise 的时候就知道它的结果，下面有两个很方便的方法可以使用：</p>
<pre><code class="javascript">var successful = AV.Promise.as('The good result.');

var failed = AV.Promise.error('An error message.');
</code></pre>

<p>除此之外，你还可以为 <code>AV.Promise</code> 提供一个函数，这个函数接收 <code>resolve</code> 和 <code>reject</code> 方法，运行实际的业务逻辑。例如：</p>
<pre><code class="javascript">var promise = new AV.Promise(function(resolve, reject){
  resolve(42);
});

promise.then(functon(ret){
  //print 42.
  console.log(ret);
});
</code></pre>

<p>尝试下两个一起用：</p>
<pre><code class="javascript">var promise = new AV.Promise(function(resolve, reject) {
  setTimeout(function() {
    if (Date.now() % 2) {
     resolve('奇数时间');
    } else {
     reject('偶数时间');
    }
  }, 2000);
});

promise.then(function(value) {
  // 奇数时间
  console.log(value);
}, function(value) {
  // 偶数时间
  console.log(value);
});
</code></pre>

<h3 id="promise_3">顺序的 Promise</h3>
<p>在你想要某一行数据做一系列的任务的时候，Promise 链是很方便的，每一个任务都等着前
一个任务结束。比如，假设你想要删除你的博客上的所有评论：</p>
<blockquote>
<p>特别说明：下文出现在代码里的 <code>_.xxx</code> 表示引用了 <a href="http://underscorejs.org/">underscore.js</a> 这个类库的方法，underscore.js 是一个非常方便的 JS 类库，提供了很多工具方法。</p>
</blockquote>
<pre><code class="javascript">var query = new AV.Query('Comment');
query.equalTo('post', post); // 假设 post 是一个已经存在的实例

query.find().then(function(results) {
  // Create a trivial resolved promise as a base case.
  var promise = AV.Promise.as();
  _.each(results, function(result) {
    // For each item, extend the promise with a function to delete it.
    promise = promise.then(function() {
      // Return a promise that will be resolved when the delete is finished.
      return result.destroy();
    });
  });
  return promise;

}).then(function() {
  // Every comment was deleted.
});
</code></pre>

<h3 id="promise_4">并行的 Promise</h3>
<p>你也可以用 Promise 来并行的进行多个任务，这时需要使用 when 方法，你可以一次同时开始几个操作。使用 <code>AV.Promise.when</code> 来创建一个新的 promise，它会在所有输入的 <code>Promise</code> 被 resolve 之后才被 resolve。即便一些输入的 promise 失败了，其他的 Promise 也会被成功执行。你可以在 callback 的参数部分检查每一个 promise 的结果。并行地进行操作会比顺序进行更快，但是也会消耗更多的系统资源和带宽。</p>
<p>简单例子：</p>
<pre><code class="javascript">function timerPromisefy(delay) {
  return new AV.Promise(function (resolve) {
    //延迟 delay 毫秒，然后调用 resolve
    setTimeout(function () {
      resolve(delay);
    }, delay);
   });
}

var startDate = Date.now();

AV.Promise.when(
  timerPromisefy(1),
  timerPromisefy(32),
  timerPromisefy(64),
  timerPromisefy(128)
).then(function (r1, r2, r3, r4) {
  //r1,r2,r3,r4 分别为1,32,64,128
  //大概耗时在 128 毫秒
  console.log(new Date() - startDate);
});

//尝试下其中一个失败的例子
var startDate = Date.now();
AV.Promise.when(
  timerPromisefy(1),
  timerPromisefy(32),
  AV.Promise.error('test error'),
  timerPromisefy(128)
).then(function () {
  //不会执行
}, function(errors){
  //大概耗时在 128 毫秒
  console.log(new Date() - startDate);
  console.dir(errors);  //print [ , , 'test error',  ]
});
</code></pre>

<p>下面例子执行一次批量删除某个 Post 的评论：</p>
<pre><code class="javascript">var query = new AV.Query('Comment');
query.equalTo('post', post);  // 假设 post 是一个已经存在的实例

query.find().then(function(results) {
  // Collect one promise for each delete into an array.
  var promises = [];
  _.each(results, function(result) {
    // Start this delete immediately and add its promise to the list.
    promises.push(result.destroy());
  });
  // Return a new promise that is resolved when all of the deletes are finished.
  return AV.Promise.when(promises);

}).then(function() {
  // Every comment was deleted.
});
</code></pre>

<p><code>when</code> 会在错误处理器中返回所有遇到的错误信息，以数组的形式提供。</p>
<p>除了 <code>when</code> 之外，还有一个类似的方法是 <code>AV.Promise.all</code>，这个方法和 <code>when</code> 的区别在于：</p>
<p>它只接受数组形式的 promise 输入，并且如果有任何一个 promise 失败，它就会直接调用错误处理器，而不是等待所有 promise 完成，其次是它的 resolve 结果返回的是数组。例如：</p>
<pre><code class="javascript">AV.Promise.all([
  timerPromisefy(1),
  timerPromisefy(32),
  timerPromisefy(64),
  timerPromisefy(128)
]).then(function (values) {
  //values 数组为 [1, 32, 64, 128]
});
//测试下失败的例子
AV.Promise.all([
  timerPromisefy(1),
  timerPromisefy(32),
  AV.Promise.error('test error'),
  timerPromisefy(128)
]).then(function () {
  //不会执行
}, function(error){
  console.dir(error);  //print 'test error'
});

//http://jsplay.avosapps.com/zuy/embed?js,console
</code></pre>

<h3 id="race">race 方法</h3>
<p><code>AV.Promise.race</code> 方法接收一个 promise 数组输入，当这组 promise 中的任何一个 promise 对象如果变为 resolve 或者 reject 的话， 该函数就会返回，并使用这个 promise 对象的值进行 resolve 或者 reject。<code>race</code>，顾名思义就是在这些 promise 赛跑，谁先执行完成，谁就先 resolve。</p>
<pre><code class="javascript">var p1 = AV.Promise.as(1);
var p2 = AV.Promise.as(2);
var p3 = AV.Promise.as(3);
Promise.race([p1, p2, p3]).then(function (value) {
  // 打印 1
  console.log(value);
});
</code></pre>

<h3 id="_54">创建异步方法</h3>
<p>有了上面这些工具以后，就很容易创建你自己的异步方法来返回 promise 了。譬如，你可以创建一个有 promise 版本的 setTimeout：</p>
<pre><code class="javascript">var delay = function(millis) {
  var promise = new AV.Promise();
  setTimeout(function() {
    promise.resolve();
  }, millis);
  return promise;
};

delay(100).then(function() {
  // This ran after 100ms!
});
</code></pre>

<h3 id="_55">兼容性</h3>
<p>在非 node.js 环境（例如浏览器环境）下，<code>AV.Promise</code> 并不兼容 <a href="https://promisesaplus.com/">Promises/A+</a> 规范，特别是错误处理这块。
如果你想兼容，可以手工启用：</p>
<pre><code class="javascript">AV.Promise.setPromisesAPlusCompliant(true);
</code></pre>

<p>在 node.js 环境下如果启用兼容 Promises/A+， 可能在一些情况下 promise 抛出的错误无法通过 <code>process.on('uncaughtException')</code> 捕捉，你可以启用额外的 debug 日志：</p>
<pre><code class="javascript">AV.Promise.setDebugError(true);
</code></pre>

<p>默认日志是关闭的。</p>
<h3 id="javascript-promise">JavaScript Promise 迷你书</h3>
<p>如果你想更深入地了解和学习 Promise，我们推荐<a href="http://liubin.github.io/promises-book/">《JavaScript Promise迷你书（中文版）》</a>这本书。</p>
<h2 id="_56">用户</h2>
<p>用户系统几乎是每款应用都要加入的功能。除了基本的注册、登录和密码重置，移动端开发还会使用手机号一键登录、短信验证码登录等功能。LeanStorage 提供了一系列接口来帮助开发者快速实现各种场景下的需求。</p>
<p><code>AVUser</code> 是用来描述一个用户的特殊对象，与之相关的数据都保存在 <code>_User</code> 数据表中。</p>
<h3 id="_57">注册</h3>
<h4 id="_58">手机号码登录</h4>
<p>一些应用为了提高首次使用的友好度，一般会允许用户浏览一些内容，直到用户发起了一些操作才会要求用户输入一个手机号，而云端会自动发送一条验证码的短信给用户的手机号，最后验证一下，完成一个用户注册并且登录的操作，例如很多团购类应用都有这种用户场景。</p>
<p>首先调用发送验证码的接口：</p>
<pre><code class="ts">    AV.Cloud.requestSmsCode('13577778888').then((success)=&gt;{
    },(error)=&gt;{
    });
</code></pre>

<p>然后在 UI 上给与用户输入验证码的输入框，用户点击登录的时候调用如下接口：</p>
<pre><code class="ts">  try {
    await AV.User.signUpOrlogInWithMobilePhone('13577778888','123456');
    // 成功
  } catch (error) {
    // 失败
  }
</code></pre>

<h4 id="_59">用户名和密码注册</h4>
<p>采用「用户名 + 密码」注册时需要注意：密码是以明文方式通过 HTTPS 加密传输给云端，云端会以密文存储密码，并且我们的加密算法是无法通过所谓「彩虹表撞库」获取的，这一点请开发者放心。换言之，用户的密码只可能用户本人知道，开发者不论是通过控制台还是 API 都是无法获取的。另外我们需要强调<strong>在客户端，应用切勿再次对密码加密，这会导致重置密码等功能失效。</strong></p>
<p>例如，注册一个用户的示例代码如下（用户名：<code>Tom</code>，密码：<code>cat!@#123</code>）：</p>
<pre><code class="ts">  let user : AV.User = new AV.User();// 新建 AVUser 对象实例
  user.setUsername('Tom');// 设置用户名
  user.setPassword('cat!@#123');// 设置密码
  user.setEmail('tom@leancloud.cn');// 设置邮箱

  user.signUp&lt;AV.User&gt;().then((loginedUser)=&gt;{
    console.log(loginedUser);
  },(error=&gt;{

  }));
</code></pre>

<p>我们建议在可能的情况下尽量使用异步版本的方法，这样就不会影响到应用程序主 UI 线程的响应。</p>
<p>如果注册不成功，请检查一下返回的错误对象。最有可能的情况是用户名已经被另一个用户注册，错误代码 <a href="../error_code.html#_202">202</a>，即 <code>_User</code> 表中的 <code>username</code> 字段已存在相同的值，此时需要提示用户尝试不同的用户名来注册。同样，邮件 <code>email</code> 和手机号码 <code>mobilePhoneNumber</code> 字段也要求在各自的列中不能有重复值出现，否则会出现 <a href="../error_code.html#_203">203</a>、<a href="../error_code.html#_214">214</a> 错误。</p>
<p>开发者也可以要求用户使用 Email 做为用户名注册，即在用户提交信息后将 <code>_User</code> 表中的 <code>username</code> 和 <code>email</code> 字段都设为相同的值，这样做的好处是用户在忘记密码的情况下可以直接使用「<a href="#重置密码">邮箱重置密码</a>」功能，无需再额外绑定电子邮件。</p>
<p>关于自定义邮件模板和验证链接，请参考博客文章 《<a href="https://blog.leancloud.cn/607/">自定义应用内用户重设密码和邮箱验证页面</a>》。</p>
<h4 id="_60">设置手机号码</h4>
<p>微信、陌陌等流行应用都会建议用户将账号和一个手机号绑定，这样方便进行身份认证以及日后的密码找回等安全模块的使用。我们也提供了一整套发送短信验证码以及验证手机号的流程，这样注册用户的时候也可以设置手机号，并且</p>
<p>为此，在注册用户的时候也可以设置手机号，并且我们提供了一整套发送短信验证码以及验证手机号的流程。这部分流程以及代码演示请参考 <a href="../sms_guide-js.html#注册验证">JavaScript 短信服务使用指南</a>。</p>
<h3 id="_61">登录</h3>
<p>我们提供了多种登录方式，以满足不同场景的应用。</p>
<h4 id="_62">用户名密码登录</h4>
<pre><code class="ts">  AV.User.logIn&lt;AV.User&gt;('Tom','cat!@#123').then((loginedUser)=&gt;{
    console.log(loginedUser);
  },(error=&gt;{
  }));
</code></pre>

<h4 id="_63">手机号密码登录</h4>
<p>请确保已详细阅读了 <a href="../sms_guide-js.html#注册验证">JavaScript 短信服务使用指南</a> 这一小节的内容，才可以顺利理解手机号匹配密码登陆的流程以及适用范围。</p>
<p>用户的手机号只要经过了验证，就可以使用手机号密码登录的功能，否则登录会失败。</p>
<pre><code class="ts">  AV.User.logInWithMobilePhone&lt;AV.User&gt;('13577778888','cat!@#123').then((loginedUser)=&gt;{
    console.log(loginedUser);
  },(error=&gt;{
  }));
</code></pre>

<h4 id="_64">手机号验证码登录</h4>
<p>中国电信、中国联通、中国移动，这三大运营商的官网登录均支持「手机号 + 密码」和「手机号 + 随机验证码」的登录方式，我们也提供了这些方式。</p>
<p>首先，调用发送登录验证码的接口：</p>
<pre><code class="ts">AV.User.requestLoginSmsCode('13577778888').then((success)=&gt;{
  },(error)=&gt;{
  });
</code></pre>

<p>然后在界面上引导用户输入收到的 6 位短信验证码：</p>
<pre><code class="ts">AV.User.logInWithMobilePhoneSmsCode('13577778888','238825').then((success)=&gt;{
  },(error)=&gt;{
  });
</code></pre>

<h4 id="sessiontoken">SessionToken</h4>
<p>所有登录接口调用成功之后，云端会返回一个 SessionToken 给客户端，客户端在发送 HTTP 请求的时候，JavaScript SDK 会在 HTTP 请求的 Header 里面自动添加上当前用户的 SessionToken 作为这次请求的发起者 <code>AV.User</code> 的身份认证信息。</p>
<h4 id="_65">账户锁定</h4>
<p>输入错误的密码或验证码会导致用户登录失败。如果在 15 分钟内，同一个用户登录失败的次数大于 6 次，该用户账户即被云端暂时锁定，此时云端会返回错误码 <code>{"code":1,"error":"登录失败次数超过限制，请稍候再试，或者通过忘记密码重设密码。"}</code>，开发者可在客户端进行必要提示。</p>
<p>锁定将在最后一次错误登录的 15 分钟之后由云端自动解除，开发者无法通过 SDK 或 REST API 进行干预。在锁定期间，即使用户输入了正确的验证信息也不允许登录。这个限制在 SDK 和云引擎中都有效。</p>
<h3 id="_66">用户的属性</h3>
<h4 id="_67">默认属性</h4>
<p>用户名，密码，邮箱是默认提供的三个属性，访问方式如下：</p>
<pre><code class="ts">  AV.User.logIn&lt;AV.User&gt;('Tom','cat!@#123').then((loginedUser)=&gt;{
    console.log(loginedUser);
    let username :string = loginedUser.getUsername();
    let email :string = loginedUser.getEmail();
    // 请注意，密码不会明文存储在云端，因此密码只能重置，不能查看
  },(error=&gt;{
  }));
</code></pre>

<p>请注意代码中，密码是仅仅是在注册的时候可以设置的属性，这部分代码参照<a href="#用户名和密码注册">用户名和密码注册</a>，它在注册完成之后并不会保存在本地（SDK 绝不会明文保存密码这种敏感数据），所以在<strong>登录之后，再访问密码这个字段是为空的。</strong></p>
<h4 id="_68">自定义属性</h4>
<p>用户对象和普通对象一样也支持添加自定义属性。
例如，为 当前用户添加年龄属性：</p>
<pre><code class="ts">  AV.User.logIn&lt;AV.User&gt;('Tom','cat!@#123').then((loginedUser)=&gt;{
    console.log(loginedUser);
    loginedUser.set('age',25);
    loginedUser.save();
  },(error=&gt;{
  }));
</code></pre>

<h4 id="_69">属性的修改</h4>
<p>这一章节内容尤为重要，因为很多开发者会产生疑惑：为什么我不能修改任意一个用户的属性？
这里需要解释的是：</p>
<blockquote>
<p>很多时候，就算是开发者也不要轻易修改用户的基本信息，比如用户的一些比较敏感的个人信息，例如手机号，社交账号等，这些都应该让用户在App中自行修改，所以为了用户数据的数据有且仅有自己在登录的情况下得以修改，LeanStorage 云端对所有针对 <code>AV.User</code> 对象的数据做了验证。</p>
</blockquote>
<p>假如，刚才我们为当前用户添加了一个 age 属性，现在我们来修改它：</p>
<pre><code class="ts">  AV.User.logIn&lt;AV.User&gt;('Tom','cat!@#123').then((loginedUser)=&gt;{
    console.log(loginedUser);
    loginedUser.set('age',25);
    loginedUser.save();
  },(error=&gt;{
  }));
</code></pre>

<p>细心的开发者应该已经发现 <code>AV.User</code> 在自定义属性上的使用与一般的 <code>AV.Object</code> 没本质区别。</p>
<h3 id="_70">重置密码</h3>
<h4 id="_71">邮箱重置密码</h4>
<p>我们都知道，应用一旦加入账户密码系统，那么肯定会有用户忘记密码的情况发生。对于这种情况，我们为用户提供了一种安全重置密码的方法。</p>
<p>重置密码的过程很简单，用户只需要输入注册的电子邮件地址即可：</p>
<pre><code class="ts">  AV.User.requestPasswordReset('myemail@example.com').then((success)=&gt;{
  },(error)=&gt;{
  });
</code></pre>

<p>密码重置流程如下：</p>
<ol>
<li>用户输入注册的电子邮件，请求重置密码；</li>
<li>LeanStorage 向该邮箱发送一封包含重置密码的特殊链接的电子邮件；</li>
<li>用户点击重置密码链接后，一个特殊的页面会打开，让他们输入新密码；</li>
<li>用户的密码已被重置为新输入的密码。</li>
</ol>
<p>关于自定义邮件模板和验证链接，请参考这篇 <a href="http://blog.leancloud.cn/blog/2014/01/09/zi-ding-yi-ying-yong-nei-yong-hu-zhong-she-mi-ma-he-you-xiang-yan-zheng-ye-mian/">博客</a></p>
<h4 id="_72">手机号码重置密码</h4>
<p>与使用 <a href="#邮箱重置密码">邮箱重置密码</a> 类似，「手机号码重置密码」使用下面的方法来获取短信验证码：</p>
<pre><code class="ts">  AV.User.requestPasswordResetBySmsCode('18612340000').then((success)=&gt;{
  },(error)=&gt;{
  });
</code></pre>

<p>注意！用户需要先绑定手机号码，然后使用短信验证码来重置密码：</p>
<pre><code class="ts">  AV.User.resetPasswordBySmsCode('123456','thenewpassword').then((success)=&gt;{
  },(error)=&gt;{
  });
</code></pre>

<h3 id="_73">当前用户</h3>
<p>打开微博或者微信，它不会每次都要求用户都登录，原因是因为在客户端做了用户数据的缓存。
因此，只要是调用了登录相关的接口，SDK 都会自动缓存登录用户的数据。
例如，判断当前用户是否为空，为空就跳转到登录页面让用户登录，如果不为空就跳转到首页：</p>
<pre><code class="ts">  let currentUser :AV.User = AV.User.current();
  if(currentUser){
    // 跳转到首页
  } else {
    //currentUser 为空时，可打开用户注册界面…
  }
</code></pre>

<p>如果不调用 <a href="#登出">登出</a> 方法，当前用户的缓存将永久保存在客户端。</p>
<h4 id="_74">登出</h4>
<p>用户登出系统，SDK 会自动的清理缓存信息。</p>
<pre><code class="ts">  AV.User.logOut();
  // 现在的 currentUser 是 null 了
  let currentUser :AV.User = AV.User.current();
</code></pre>

<h3 id="_75">用户的查询</h3>
<p>请注意，<strong>新创建的应用的用户表 <code>_User</code> 默认关闭了查询权限</strong>。你可以通过 Class 权限设置打开查询权限，请参考 <a href="../data_security.html#Class_级别的_ACL">数据与安全 &middot; Class 级别的权限</a>。我们推荐开发者在 <a href="../leanengine_overview.html">云引擎</a> 中封装用户查询，只查询特定条件的用户，避免开放用户表的全部查询权限。</p>
<p>查询用户代码如下：</p>
<pre><code class="ts">  let query : AV.Query = new AV.Query('_User');
</code></pre>

<h3 id="_76">浏览器中查看用户表</h3>
<p>用户表是一个特殊的表，专门存储 AVUser 对象。在浏览器端，你会看到一个 <code>_User</code> 表。</p>
<h2 id="_77">角色</h2>
<p>关于用户与角色的关系，我们有一个更为详尽的文档介绍这部分的内容，并且针对权限管理有深入的讲解，详情请点击 <a href="../acl_guide-js.html">JavaScript 权限管理使用指南</a>。</p>
<h2 id="_78">应用内搜索</h2>
<p>应用内搜索是一个针对应用数据进行全局搜索的接口，它基于搜索引擎构建，提供更强大的搜索功能，深入了解其用法和阅读示例代码请点击 <a href="../app_search_guide.html">JavaScript 应用内搜索指南</a></p>
<h2 id="_79">应用内社交</h2>
<p>应用内社交，又称「事件流」，在应用开发中出现的场景非常多，包括用户间关注（好友）、朋友圈（时间线）、状态、互动（点赞）、私信等常用功能，这部分文档请参考：<a href="../status_system.html#JavaScript_SDK">JavaScript 应用内社交模块</a></p>
<h2 id="push">Push 通知</h2>
<p>通过 JavaScript SDK 也可以向移动设备推送消息，使用也非常简单。</p>
<p>如果想在 Web 端独立使用推送模块，包括通过 Web 端推送消息到各个设备、以及通过 Web 端也可以接收其他端的推送，可以了解下我们的 <a href="../js_push.html">JavaScript 推送 SDK 使用指南</a> 来获取更详细的信息。</p>
<p>一个简单例子推送给所有订阅了 <code>public</code> 频道的设备：</p>
<pre><code class="javascript">AV.Push.send({
  channels: [ 'Public' ],
  data: {
    alert: 'Public message'
  }
});
</code></pre>

<p>这就向订阅了 <code>public</code> 频道的设备发送了一条内容为 <code>public message</code> 的消息。</p>
<p>如果希望按照某个 <code>_Installation</code> 表的查询条件来推送，例如推送给某个 <code>installationId</code> 的 Android 设备，可以传入一个 <code>AV.Query</code> 对象作为 <code>where</code> 条件：</p>
<pre><code class="javascript">var query = new AV.Query('_Installation');
query.equalTo('installationId', installationId);
AV.Push.send({
  where: query,
  data: {
    alert: 'Public message'
  }
});
</code></pre>

<p>此外，如果你觉得 AV.Query 太繁琐，也可以写一句 <a href="../cql_guide.html">CQL</a> 来搞定：</p>
<pre><code class="javascript">AV.Push.send({
  cql: 'select * from _Installation where installationId=&quot;设备id&quot;',
  data: {
    alert: 'Public message'
  }
});
</code></pre>

<p><code>AV.Push</code> 的更多使用信息参考 API 文档 <a href="../../api-docs/javascript/symbols/AV.Push.html">AV.Push</a>。</p>
<p>更多推送的查询条件和格式，请查阅我们的<a href="../push_guide.html">Push Notification指南</a>来获取更详细的信息。</p>
<p>iOS 设备可以通过 <code>prod</code> 属性指定使用测试环境还是生产环境证书：</p>
<pre><code class="javascript">AV.Push.send({
  prod: 'dev',
  data: {
    alert: 'Public message'
  }
});
</code></pre>

<p><code>dev</code> 表示开发证书，<code>prod</code> 表示生产证书，默认生产证书。</p>
<h2 id="webview">WebView 中使用</h2>
<p>JS SDK 支持在各种 WebView 中使用（包括 PhoneGap/Cordova、微信 WebView 等）。</p>
<h3 id="android-webview">Android WebView 中使用</h3>
<p>如果是 Android WebView，在 Native 代码创建 WebView 的时候你需要打开几个选项，
这些选项生成 WebView 的时候默认并不会被打开，需要配置：</p>
<ol>
<li>因为我们 JS SDK 目前使用了 window.localStorage，所以你需要开启 WebView 的 localStorage；设置方式：</li>
</ol>
<p><code>java
  yourWebView.getSettings().setDomStorageEnabled(true);</code>
2. 如果你希望直接调试手机中的 WebView，也同样需要在生成 WebView 的时候设置远程调试，具体使用方式请参考 <a href="https://developer.chrome.com/devtools/docs/remote-debugging">Google 官方文档</a>。</p>
<p><code>java
  if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) {
      yourWebView.setWebContentsDebuggingEnabled(true);
  }</code></p>
<p>注意：这种调试方式仅支持 Android 4.4 已上版本（含 4.4）
3. 如果你是通过 WebView 来开发界面，Native 调用本地特性的 Hybrid 方式开发你的 App。比较推荐的开发方式是：通过 Chrome 的开发者工具开发界面部分，当界面部分完成，与 Native 再来做数据连调，这种时候才需要用 Remote debugger 方式在手机上直接调试 WebView。这样做会大大节省你开发调试的时间，不然如果界面都通过 Remote debugger 方式开发，可能效率较低。
4. 为了防止通过 JavaScript 反射调用 Java 代码访问 Android 文件系统的安全漏洞，在 Android 4.2 以后的系统中间，WebView 中间只能访问通过 <a href="http://developer.android.com/reference/android/webkit/JavascriptInterface.html">@JavascriptInterface</a> 标记过的方法。如果你的目标用户覆盖 4.2 以上的机型，请注意加上这个标记，以避免出现 <strong>Uncaught TypeError</strong>。</p></div>
        </div>

        <footer class="col-md-12">
            <hr>
            
                <center>WuJun</center>
            
            <center>Documentation built with <a href="http://www.mkdocs.org/">MkDocs</a>.</center>
        </footer>

        <script src="../../js/jquery-1.10.2.min.js"></script>
        <script src="../../js/bootstrap-3.0.3.min.js"></script>
        <script src="../../js/highlight.pack.js"></script>
        <script>var base_url = '../..';</script>
        <script data-main="../../mkdocs/js/search.js" src="../../mkdocs/js/require.js"></script>
        <script src="../../js/base.js"></script>

        <div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="Search Modal" aria-hidden="true">
            <div class="modal-dialog">
                <div class="modal-content">
                    <div class="modal-header">
                        <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
                        <h4 class="modal-title" id="exampleModalLabel">Search</h4>
                    </div>
                    <div class="modal-body">
                        <p>
                            From here you can search these documents. Enter
                            your search terms below.
                        </p>
                        <form role="form">
                            <div class="form-group">
                                <input type="text" class="form-control" placeholder="Search..." id="mkdocs-search-query">
                            </div>
                        </form>
                        <div id="mkdocs-search-results"></div>
                    </div>
                    <div class="modal-footer">
                    </div>
                </div>
            </div>
        </div>
    </body>
</html>